<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>B站自动回复弹幕机</title>
      <link href="/2021/06/16/danmuji/"/>
      <url>/2021/06/16/danmuji/</url>
      
        <content type="html"><![CDATA[<h1 id="简介（非正式）"><a href="#简介（非正式）" class="headerlink" title="简介（非正式）"></a>简介（非正式）</h1><p>最近在直播学习整理，正好觉得直播间太单调，整了个弹幕机。</p><h1 id="大概构思"><a href="#大概构思" class="headerlink" title="大概构思"></a>大概构思</h1><p>需要先收集弹幕信息，然后根据相应的弹幕自动回复预设的答案。</p><h1 id="1-收集弹幕信息"><a href="#1-收集弹幕信息" class="headerlink" title="1.收集弹幕信息"></a>1.收集弹幕信息</h1><p>运用Python中request库post的协议获取输入直播间的弹幕。</p><pre><code class="python">    req = requests.post(url, data=data,headers=headers)</code></pre><p>url是进入直播间网络版本，然后开发者工具中Network中的gethistory获取的。<br><img src="https://res.cloudinary.com/db6zr5nzu/image/upload/v1623823716/gethistoryRespond_zrikby.png" alt="gethistoryResspond"><br>然后捕获的数据如下图所示。<br><img src="https://res.cloudinary.com/db6zr5nzu/image/upload/v1623824607/data_lkwxlz.png" alt="Data"><br>于是用Python中的json.loads把json字符串转换成可以处理的形式。然后用两个字典形式就能直接获取信息，然后我只爬取了发弹幕的时间，名称和内容。最后制作成如下形式。<br><img src="https://res.cloudinary.com/db6zr5nzu/image/upload/v1623824607/data_lkwxlz.png" alt="Data"></p><h1 id="2-发送弹幕"><a href="#2-发送弹幕" class="headerlink" title="2.发送弹幕"></a>2.发送弹幕</h1><p>这个根据网上的方法需要先在直播间发送一条弹幕，然后在Network中搜索send标签，然后需要获取send中很多header的数据和本账户的cookie，最后可以用这个数据模拟用户发弹幕的场景。（前几天不小心把cookie传到github上了…第二天名字就被人改了= =）</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>参考了如何爬取弹幕。<br><a href="https://www.bilibili.com/video/BV1nT4y1E7a3?from=search&amp;seid=13430385489445432762">https://www.bilibili.com/video/BV1nT4y1E7a3?from=search&amp;seid=13430385489445432762</a></p>]]></content>
      
      
      <categories>
          
          <category> 弹幕机自动回复 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> script </tag>
            
            <tag> ui </tag>
            
            <tag> bilibili </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPU系列总目录</title>
      <link href="/2021/06/13/Gpu_index/"/>
      <url>/2021/06/13/Gpu_index/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>从这篇博文开始就开始整理与GPU相关的内容了。</p><h1 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录<a href="https://zhanglinfeng09.com/2021/06/11/gpu1/"></a></h1><p>这一系列将按照如下顺序对GPU知识进行系统性的梳理。</p><h2 id="1-GPU功能及特性1"><a href="#1-GPU功能及特性1" class="headerlink" title="1.GPU功能及特性1"></a>1.<a href="https://zhanglinfeng09.com/2021/06/11/gpu1/">GPU功能及特性1</a></h2><p>首先会简略的介绍GPU是什么，GPU具有什么样的特点和他的应用前景。</p><h2 id="2-GPU功能及特性2"><a href="#2-GPU功能及特性2" class="headerlink" title="2.GPU功能及特性2"></a>2.<a href="https://zhanglinfeng09.com/2021/06/13/gpu2/">GPU功能及特性2</a></h2><p>这部分会从GPU软件语言cuda入手，对GPU的一些性能上的特点进行描述，如shared memory，band conflict 和 branch/memory divergence等。</p><h2 id="3-GPU-架构"><a href="#3-GPU-架构" class="headerlink" title="3.GPU 架构"></a>3.GPU 架构</h2><p>这一部分会根据先前了解的一些软件特性描述GPU硬件上的设计及特点。</p>]]></content>
      
      
      <categories>
          
          <category> GPU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPU </tag>
            
            <tag> 目录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPU功能及特性2</title>
      <link href="/2021/06/13/gpu2/"/>
      <url>/2021/06/13/gpu2/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>这章节主要介绍GPU软件上的架构，具体参考NVIDIA官方手册。</p><h1 id="线程结构"><a href="#线程结构" class="headerlink" title="线程结构"></a>线程结构</h1><p><img src="https://docs.nvidia.com/cuda/cuda-c-programming-guide/graphics/grid-of-thread-blocks.png" alt="线程结构"><br>如上图所示，GPU对线程的控制具体具体由Grid，block和thread三级进行分级。Grid是最高级的他直接控制block数量与空间上的排列。可以把grid看作是一个每个元素是block的三维矩阵。而block又是一个每个元素是thread的三维矩阵。（图中只是个（x,y,0）的二维矩阵）</p><p>线程是执行任务的最基础单元，通过三维矩阵的特点能让软件工程师更好的完成某些任务.</p>]]></content>
      
      
      <categories>
          
          <category> GPU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPU </tag>
            
            <tag> 目录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPU功能及特性1</title>
      <link href="/2021/06/11/gpu1/"/>
      <url>/2021/06/11/gpu1/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>这章节主要介绍GPU是什么，具有什么功能以及为什么选择GPU。</p><h1 id="GPU是什么"><a href="#GPU是什么" class="headerlink" title="GPU是什么"></a>GPU是什么</h1><p>GPU全称Graphics processing unit（图像处理单位）但是这系列主要介绍GPGPU就是general purpose GPU，就是做通用计算的GPU。（暂不涉及渲染的模型和理论）</p><h2 id="具体特点"><a href="#具体特点" class="headerlink" title="具体特点"></a>具体特点</h2><h3 id="1-高可编程性。"><a href="#1-高可编程性。" class="headerlink" title="1.高可编程性。"></a>1.高可编程性。</h3><p>cuda等进行编程。</p><h3 id="2-商品级硬件。"><a href="#2-商品级硬件。" class="headerlink" title="2.商品级硬件。"></a>2.商品级硬件。</h3><p>价格不算过于昂贵。</p><h3 id="3-数以百计的ALU（逻辑运算单元），数以万计的线程数。"><a href="#3-数以百计的ALU（逻辑运算单元），数以万计的线程数。" class="headerlink" title="3.数以百计的ALU（逻辑运算单元），数以万计的线程数。"></a>3.数以百计的ALU（逻辑运算单元），数以万计的线程数。</h3><p>意味着GPU可以并行处理非常多的线程，效率高。</p><h1 id="效率与可编程性"><a href="#效率与可编程性" class="headerlink" title="效率与可编程性"></a>效率与可编程性</h1><p><img src="https://res.cloudinary.com/db6zr5nzu/image/upload/v1623414334/%E5%8F%AF%E7%BC%96%E7%A8%8B%E6%80%A7vs%E7%A1%AC%E4%BB%B6%E6%95%88%E7%8E%87_m0mksy.png" alt="效率与可编程性"><br>上图是一个各个设计的效率和可编程性的一个比较图。从可编程性的角度来说单核的CPU是最好编程的，因为他只有一个核心，不需要考虑多核对数据的原子操作（atomic operation），多核次之。GPU比多核较难编程一点，不仅仅因为GPU的核数是多核的几百上千倍，而且GPU为解决多核同时调用数据时，内存带宽对效率的影响，设计与CPU非常不同。ASIC设计是数字IC中为了某一个目标专门定制的硬件电路。因为硬件定制的电路需要先RTL设计，然后形式仿真测试逻辑，再静态时序分析解决诸如毛刺，延迟电路和时钟偏移等问题，再制造，最后ATGP测试制造中有没有defects，所以这个流程是很复杂的。当然制造CPU，GPU也需要经历以上的过程，但是我们可以根据现成的CPU和GPU完成任务，而不需要每次根据特定目标进行<strong>设计及制造</strong>达到定制电路。</p><p>接下来聊一下各个数据之间效率的对比。</p><p>效率主要考虑的问题在于实现功能需要的时间和在芯片上占用的面积上多方面考虑。因为CPU需要处理一些比较总体的任务，所以有处理不同功能的模块。同时协调不同的功能也需要额外的时间（如果指令集过大，检索之类的时候也会花费更多的时间，可能更重要的因素一下子想不到。）因为CPU需要的功能多，所以在芯片上占用的面积会比GPU和ASIC多。GPU其实是针对特定任务进行加速的架构。（例如渲染，计算加速，机器学习的卷积等能高并行的任务。）ASIC是针对摸一个特定的运用场景的，所以他只会包含能实现这个场景最少的模块和功能。功能模块的减少能有效的减少crtical path导致时间减少。具体见下图。<br><img src="https://docs.nvidia.com/cuda/cuda-c-programming-guide/graphics/gpu-devotes-more-transistors-to-data-processing.png" alt="官方图"><br>（GPU NVIDIA官方图）<br>相比较CPU，GPU有非常多的ALU单元，较少的cache。因为GPU的cache hit是较为困难的，而且可以考多线程减少cache miss带来的负影响。同时GPU把大量的alu连起来成为一个wrap（NVIDIA）或者wavefront（AMD），用一个control单元进行控制，可以省去不少control单元的面积。</p><h1 id="特点与总结"><a href="#特点与总结" class="headerlink" title="特点与总结"></a>特点与总结</h1><p>综上所述，GPU具有非常多的线程（threads），以及有一个控制一组线程的control单元。所以当需要很多线程处理同一类型的任务的时候，可以很好的发挥GPU的特点。</p>]]></content>
      
      
      <categories>
          
          <category> GPU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPU </tag>
            
            <tag> 目录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>行波进位加法器和超前进位加法器</title>
      <link href="/2021/06/10/CLA-adder/"/>
      <url>/2021/06/10/CLA-adder/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在运算中，加法的效率和占用的资源一直是比较重要的因素，所有这篇博文将重点介绍RCA（行波进位加法器）和CLA（超前进位加法器）各自的优缺点。</p><span id="more"></span><h1 id="RCA介绍"><a href="#RCA介绍" class="headerlink" title="RCA介绍"></a>RCA介绍</h1><p>RCA作为一个比较直接得出的加法器，效率相比CLA稍低，但是占用的资源要少很多。<br><img src="https://res.cloudinary.com/db6zr5nzu/image/upload/v1594875033/Full_adder_u3e1jx.png"><br>上图是RCA的组成图。<br>每一位的计算都需要上一个全加器的Cout信号，所有信号的最长延长为2个门延迟4+1为9的延迟。如果计算的位数上升的话，需要2n+1的延迟。</p><p>但是每个全加器只需要5个门的资源。</p><h1 id="CLA介绍"><a href="#CLA介绍" class="headerlink" title="CLA介绍"></a>CLA介绍</h1><p>CLA作为一个速度优化的加法器，对于多位加法计算效率有显著提高，但是排线和资源占用的比较多。<br><img src="https://res.cloudinary.com/db6zr5nzu/image/upload/v1595224271/CLA_adder_tx272x.png"><br>上图是CLA的组成图。<br>这里的Cin计算取决于前面全加器就算得到的P和G的值，可以通过并行计算，最后通过OR门进行汇总。除了第一位的Cin延迟为2，其他的Cin延迟为3.那最长的延迟为Cin3 + 1 = 4。因为S = A[3] ^ B[3] ^ Cin[3]。</p><p>如果CLA的输入信号数量有限制的话，延迟和复杂度都会提升。<br><img src="https://res.cloudinary.com/db6zr5nzu/image/upload/v1595224643/complex_CLA_ie6tff.png"><br>如上图所示，如果输入限制四个的话，一个16进制的加法器就需要两层的P/G综合才能实现CLA的加法，这样以来加法器的延迟与电路复杂度也会变糟。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>以下是本人写的CLA的加法器。</p><h2 id="CLA模块代码"><a href="#CLA模块代码" class="headerlink" title="CLA模块代码"></a>CLA模块代码</h2><pre><code class="verilog">module FA_Seq(input logic unsigned [5:0] A,input logic unsigned [5:0] B,output logic [6:0] Sum,output logic Cout);reg [5:0] P;reg [5:0] G;reg [5:0] C;integer i;always_comb beginP = A ^ B; //p flag XOR门G = A &amp; B; //g  flag endalways_comb beginC[0] = G[0] | (P[0] &amp; 1&#39;b0);for (i = 0;i &lt; 5;i = i + 1) beginC[i+1] = G[i+1] | (C[i] &amp; P[i+1]); endSum = (A ^ B) ^ &#123;C[4:0],1&#39;b0&#125;;Sum[6] = C[5];endassign Cout = C[5];endmodule</code></pre><p>因为RCA加法器较为简单所以就不写了。</p><h2 id="CLA测试代码"><a href="#CLA测试代码" class="headerlink" title="CLA测试代码"></a>CLA测试代码</h2><p>然后用不规范的例子简单的做了测试，应该没有问题。</p><pre><code class="verilog">module tb_FA_Seq;`timescale 1 ns / 1 nsparameter PERIOD = 10;int testcase = 0;logic [3:0] array1 ;logic a,b,c;logic CLK = 0;reg [7:0] aa;reg [6:0] bb;reg [5:0] cc;reg [5:0] A,B;reg [6:0] Sum;reg Cout;FA_Seq PROG (A, B, Sum, Cout);always #(PERIOD /2) CLK ++;initial begin  //initalidalization  A = &#39;0;  B = &#39;0;  //Cin = &#39;0;  Sum = &#39;0;  Cout = &#39;0;  //case 1   @(posedge CLK)  testcase ++;  A = &#39;1;  B = &#39;0;  //Cin = 0;   //case 2  @(posedge CLK)  testcase ++;  A = &#39;0;  B = &#39;1;  //Cin = 0;  //case 3  @(posedge CLK)  testcase ++;  A = &#39;1;  B = &#39;1;  //case 4;  @(posedge CLK)  A = 6&#39;d12;  B = 6&#39;d23;  //case 5;  @(posedge CLK)  A = 6&#39;d3;  B = 6&#39;d8;  //case 6;  @(posedge CLK)  A = 6&#39;d4;  B = 6&#39;d6;  @(posedge CLK)$stop;endendmodule</code></pre><h2 id="Waveform"><a href="#Waveform" class="headerlink" title="Waveform"></a>Waveform</h2><p>waveform如下图所示<br><img src="https://res.cloudinary.com/db6zr5nzu/image/upload/v1595231937/adder_waveform_xauyou.png"></p><p>以上是CLA和RCA加法器的介绍</p>]]></content>
      
      
      <categories>
          
          <category> 数字电路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Systemverilog </tag>
            
            <tag> 加法器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业设计</title>
      <link href="/2020/05/23/senior-design/"/>
      <url>/2020/05/23/senior-design/</url>
      
        <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>这个项目主要是实现了一个电子名片的功能。这是个实体电子名片的设计，由一个硅谷工程师微型计算机名片得到灵感。由于设计难度过大，对计算机组成在当时还不熟悉，所以做了较大的改变。</p><span id="more"></span><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>设计最初打算用micro-python做一个USB接口的优盘，然后插入电脑时，能自动弹开一个像本博客一样的网页。但是由于太过简单，而且多数电脑对自动打开程序，类似病毒的脚本的行为会进行安全措施，这个毕业设计在一开始险些被砍掉。<br>最后改成了如下的需求才给予通过。</p><p>该电子名片在不接入电脑时，能显示所有者的姓名，地址，电话号码，邮箱，地址等文本内容，同时能显示个人头像或者微信二维码等图像。</p><p>当手机靠近该电子名片，并打开任意NFC app能接受预先储存于电子名片内的信息，比如个人简历的PDF或者个人网站域名。</p><p>当电子名片接入电脑时，能出现像正常U盘一样在电脑上访问的磁盘，里面的文件都是只读的权限，同时不能复制，保护用户的个人隐私，并且保证用户的所有权。只有用户或者访问者打开U盘中的UI程序输入正确的密码，才给予写和复制的权限。密码保存在原地，但是被加密。同时改变电子名片显示的信息和图片均可以通过该UI程序进行修改，同时NFC需要发送的内容也可以进行修改。当保存键按下时，信息会自动更新。</p><h4 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h4><p><img src="https://res.cloudinary.com/djyodckal/image/upload/v1590173169/sketchpng_up0mrk.png"></p><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><p>大容量usb储存：实现U盘功能，同时需要足够储存大小。用到了安卓手机的Micro-SD 卡。<br>黑白墨迹屏幕：显示文本和图片。<br>NFC：发送信息给手机。<br><img src="https://pic4.zhimg.com/80/v2-0d60706e016452b7901ca174755b186b_1440w.jpg"></p><h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p><img src="https://res.cloudinary.com/djyodckal/image/upload/v1590173238/blockDia_rntrjc.png"></p><h3 id="选择这款屏幕的原因"><a href="#选择这款屏幕的原因" class="headerlink" title="选择这款屏幕的原因"></a>选择这款屏幕的原因</h3><p>因为当初设计的时候需要一个尽量小，且能持续显示的屏幕。所以显示了像kindle一样的墨迹屏，而且该屏幕不需要供电就能维持显示的状态，所以完美符合了需求，再者因为若干墨迹屏中只有这款屏幕的刷新时间在两秒以内，最终就选择了这款产品。</p><h3 id="次级系统1：USB-大容量储存"><a href="#次级系统1：USB-大容量储存" class="headerlink" title="次级系统1：USB 大容量储存"></a>次级系统1：USB 大容量储存</h3><p><img src="https://res.cloudinary.com/djyodckal/image/upload/v1590173358/mass_storage_ocpop6.png"></p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>该部分用STM32cubeIDE 和STM32MUX 一起完成，打开了USB mass storage然后修改storage_config_if.c中的读写和获取状态方程即可。但是中间一直有个问题，USB和盘符一张无法正确读取，直到让写的方程等到能读到卡的状态后，运行指令才成功，但是需要大概一分钟电脑才能读到磁盘。</p><h3 id="次级系统2：图像处理和Micro-SD卡读写"><a href="#次级系统2：图像处理和Micro-SD卡读写" class="headerlink" title="次级系统2：图像处理和Micro-SD卡读写"></a>次级系统2：图像处理和Micro-SD卡读写</h3><p><img src="https://res.cloudinary.com/djyodckal/image/upload/v1590173357/ImagePro_vdfpdc.png"><br><img src="https://res.cloudinary.com/djyodckal/image/upload/v1590173539/flowchart_jonb1v.png"></p><h4 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h4><p>该部分需要读取已经保存在Micro-SD卡中解码的图像的数列及文本，然后改变大小，改变色彩显示模式，最后根据屏幕驱动把图像和文本在屏幕上显示出来。</p><h3 id="次级系统3：UI和NFC模块"><a href="#次级系统3：UI和NFC模块" class="headerlink" title="次级系统3：UI和NFC模块"></a>次级系统3：UI和NFC模块</h3><p><img src="https://res.cloudinary.com/djyodckal/image/upload/v1590173539/UI_lepqzz.png"><br><img src="https://res.cloudinary.com/djyodckal/image/upload/v1590173539/NFC_wab78v.png"></p><h4 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h4><p>该部分需要在插入U盘后，有一个可以执行的UI程序，方便用户。同时NFC模块读取SD卡中的相应内容，储存在NFC模块的标签上。</p><h3 id="次级系统4：图像解码"><a href="#次级系统4：图像解码" class="headerlink" title="次级系统4：图像解码"></a>次级系统4：图像解码</h3><p><img src="https://res.cloudinary.com/djyodckal/image/upload/v1590173537/Decoder_hdstmz.png"></p><h4 id="过程-3"><a href="#过程-3" class="headerlink" title="过程"></a>过程</h4><p>该部分需要在插入U盘后，有一个可以执行的UI程序，方便用户。同时NFC模块读取SD卡中的相应内容，储存在NFC模块的标签上。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后nfc的步骤目前只能读取信息还不能写，和主单片机的交互的spi也没有实现。<br>目前就是这样，整张名片成本大概50美元，并且usb大容量储存的相应时间比较久，需要一两分钟，原因还未知。</p><h3 id="Github链接及英文描述"><a href="#Github链接及英文描述" class="headerlink" title="Github链接及英文描述"></a>Github链接及英文描述</h3><p><a href="https://github.com/Zhang-Rick/ECE49022_Senior_Design">https://github.com/Zhang-Rick/ECE49022_Senior_Design</a><br>演示视频<br><a href="https://www.youtube.com/watch?v=P2ZDCQjS7qo">https://www.youtube.com/watch?v=P2ZDCQjS7qo</a></p>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Embedded C </tag>
            
            <tag> project </tag>
            
            <tag> hardware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>singlecycle设计及实现3(control unit控制单元)</title>
      <link href="/2020/03/24/singlecycle-control/"/>
      <url>/2020/03/24/singlecycle-control/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这篇博文主要介绍的是基于mips的 singlecycle CPU设计及实现的第三个单元control_unit算术逻辑单元。</p><span id="more"></span><h3 id="RTL-图像"><a href="#RTL-图像" class="headerlink" title="RTL 图像"></a>RTL 图像</h3><p><img src="https://res.cloudinary.com/djyodckal/image/upload/v1584759605/datapath_jchv0c.png"><br>接着上次博客对alu的介绍，本次本应该讲述memory储存的。涉及到储存，缓存就是性能提升的一个重要的步骤，但是由于缓存的内容比较多，所以打算单独放出来单独讨论。这次将讲解control_unit控制单元。</p><h3 id="控制单元详解"><a href="#控制单元详解" class="headerlink" title="控制单元详解"></a>控制单元详解</h3><p><img src="https://res.cloudinary.com/djyodckal/image/upload/v1585026711/image001_mtevmx.jpg"><br>依照上图，控制单元代表的是当完整的指令被解码的时候，具体要用哪些模块就会马上知道，所以控制这些模块的信号也会马上释放。</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p><img src="https://res.cloudinary.com/djyodckal/image/upload/v1585027156/%E5%9B%BE%E7%89%87243_vc15c2.png"><br>例如我们解码的指令是ld rt，imm16(rs)<br>含义：取rs+imm16储存地址上的值，并把它赋给rt。<br>首先需要通过alu把实际地址算出来，然从储存读值，最后把值储存到寄存器中特定的地址。</p><ol><li>数据输入alu逻辑算术单元，busA不变，busB为带符号的立即执行，所以选择{16*最高位,原来16位数字}。ALUsrc = signExT</li><li>加法计算实际地址，ALUop = add</li><li>从memory储存中读取，不是写。MemWr = 0，DataIn 无所谓</li><li>选取memory输出的值。MemtoReg = 1，选储存出来的值</li><li>对寄存器进行写入。RegWr = 1</li><li>写入目标地址为rt。RegDst= rt<br>所以以上就是解码这个指令得到的所有的控制信号。所以如果要正确的处理所有的信号，需要理解所有信号的作用及自己构建的CPU的功能。</li></ol><p>以下的是这个CPU所有需要包括的指令。</p><pre><code class="c">MIPS Instruction Set Architecture---------------------&lt;reserved registers&gt;------------------------$0                   zero$1                   assembler temporary$29                  stack pointer$31                  return address---------------------&lt;R-type Instructions&gt;-----------------------ADDU   $rd,$rs,$rt   R[rd] &lt;= R[rs] + R[rt] (unchecked overflow)ADD    $rd,$rs,$rt   R[rd] &lt;= R[rs] + R[rt]AND    $rd,$rs,$rt   R[rd] &lt;= R[rs] AND R[rt]JR     $rs           PC &lt;= R[rs]NOR    $rd,$rs,$rt   R[rd] &lt;= ~(R[rs] OR R[rt])OR     $rd,$rs,$rt   R[rd] &lt;= R[rs] OR R[rt]SLT    $rd,$rs,$rt   R[rd] &lt;= (R[rs] &lt; R[rt]) ? 1 : 0SLTU   $rd,$rs,$rt   R[rd] &lt;= (R[rs] &lt; R[rt]) ? 1 : 0SLLV   $rd,$rs,$rt   R[rd] &lt;= R[rt] &lt;&lt; [0:4] R[rs]SRLV   $rd,$rs,$rt   R[rd] &lt;= R[rt] &gt;&gt; [0:4] R[rs]SUBU   $rd,$rs,$rt   R[rd] &lt;= R[rs] - R[rt] (unchecked overflow)SUB    $rd,$rs,$rt   R[rd] &lt;= R[rs] - R[rt]XOR    $rd,$rs,$rt   R[rd] &lt;= R[rs] XOR R[rt]---------------------&lt;I-type Instructions&gt;-----------------------ADDIU  $rt,$rs,imm   R[rt] &lt;= R[rs] + SignExtImm (unchecked overflow)ADDI   $rt,$rs,imm   R[rt] &lt;= R[rs] + SignExtImmANDI   $rt,$rs,imm   R[rt] &lt;= R[rs] &amp; ZeroExtImmBEQ    $rs,$rt,label PC &lt;= (R[rs] == R[rt]) ? npc+BranchAddr : npcBNE    $rs,$rt,label PC &lt;= (R[rs] != R[rt]) ? npc+BranchAddr : npcLUI    $rt,imm       R[rt] &lt;= &#123;imm,16b&#39;0&#125;LW     $rt,imm($rs)  R[rt] &lt;= M[R[rs] + SignExtImm]ORI    $rt,$rs,imm   R[rt] &lt;= R[rs] OR ZeroExtImmSLTI   $rt,$rs,imm   R[rt] &lt;= (R[rs] &lt; SignExtImm) ? 1 : 0SLTIU  $rt,$rs,imm   R[rt] &lt;= (R[rs] &lt; SignExtImm) ? 1 : 0SW     $rt,imm($rs)  M[R[rs] + SignExtImm] &lt;= R[rt]LL     $rt,imm($rs)  R[rt] &lt;= M[R[rs] + SignExtImm]; rmwstate &lt;= addrSC     $rt,imm($rs)  if (rmw) M[R[rs] + SignExtImm] &lt;= R[rt], R[rt] &lt;= 1 else R[rt] &lt;= 0XORI   $rt,$rs,imm   R[rt] &lt;= R[rs] XOR ZeroExtImm---------------------&lt;J-type Instructions&gt;-----------------------J      label         PC &lt;= JumpAddrJAL    label         R[31] &lt;= npc; PC &lt;= JumpAddr---------------------&lt;Other Instructions&gt;------------------------HALT---------------------&lt;Pseudo Instructions&gt;-----------------------PUSH   $rs           $29 &lt;= $29 - 4; Mem[$29+0] &lt;= R[rs] (sub+sw)POP    $rt           R[rt] &lt;= Mem[$29+0]; $29 &lt;= $29 + 4 (add+lw)NOP                  Nop----------------------------------------------------------------------------------------------------------------------------------org  Addr         Set the base address for the code to follow chw  #            Assign value to half word memorycfw  #            Assign value to word of memory</code></pre><p>所以根据以上的指令集进行了归类，主要注意的是ALUsrc需要哪些input，做出了以下的表格进行整理。</p><pre><code class="c">/*    |    Var    |    00     |    01     |    10     |    11    |    |  ALUSrc   |    rs     |  unsign   |    sll    |   sign   |    |  RegDst   |    rt     |    rd     |    31     |   zero   |    |  PCSrc    |    no     |  Branch   |    JR     |  J/JAL   |    |  DAtaSrc  |  portout  | dmemload  |    lui    |   PC+4   |*/</code></pre><p>`所以看了一下，数据线B总共有datab，没符号立即数，有符号立即数以及SLL这种只取寄存器其中的五位。<br>JAL这个指令需要跳转，同时把跳转回来的程序地址储存到31号寄存器中。</p><h5 id="主代码control-unit-sv"><a href="#主代码control-unit-sv" class="headerlink" title="主代码control_unit.sv"></a>主代码control_unit.sv</h5><pre><code class="verilog">`include &quot;cpu_types_pkg.vh&quot;`include &quot;control_unit_if.vh&quot;module control_unit(    control_unit_if.ctr cuif);/*    |    Var    |    00     |    01     |    10     |    11    |    |  ALUSrc   |    rs     |  unsign   |    slt    |   sign   |    |  RegDst   |    rt     |    rd     |    31     |   zero   |    |  PCSrc    |    no     |  Branch   |    JR     |  J/JAL   |    |  DAtaSrc  |  portout  | dmemload  |    lui    |   PC+4   |*/import cpu_types_pkg::*;logic equFlag;always_comb begin    equFlag = 0;//beq bne flag    cuif.PCSrc = 0;//pc mux    cuif.DataSrc = 0;//memory to register mux    cuif.ALUSrc = 0;//data bus 2 mux    cuif.RegDest = 0;//destination register mux        cuif.memREN = 0;    cuif.memWEN = 0;    cuif.RegWEN = 0;    cuif.halt = 0;    cuif.branch = 0;    cuif.ALUOP = ALU_ADD;    case(cuif.opcode)        RTYPE: begin            case(cuif.funct)                SLLV: begin                    cuif.ALUOP = ALU_SLL;                    cuif.RegWEN = 1;                    cuif.RegDest = 1;                    cuif.ALUSrc = 2&#39;b10;                end                SRLV: begin                    cuif.ALUOP = ALU_SRL;                    cuif.RegWEN = 1;                    cuif.RegDest = 1;                    cuif.ALUSrc = 2&#39;b10;                end                JR:  begin                    cuif.PCSrc = 2&#39;b10;                end                ADD: begin                    cuif.ALUOP = ALU_ADD;                    cuif.RegWEN = 1;                    cuif.RegDest = 1;                end                ADDU: begin                    cuif.ALUOP = ALU_ADD;                    cuif.RegWEN = 1;                    cuif.RegDest = 1;                end                SUB: begin                    cuif.ALUOP = ALU_SUB;                    cuif.RegWEN = 1;                    cuif.RegDest = 1;                end                SUBU: begin                    cuif.ALUOP = ALU_SUB;                    cuif.RegWEN = 1;                    cuif.RegDest = 1;                end                AND: begin                    cuif.ALUOP = ALU_AND;                    cuif.RegWEN = 1;                    cuif.RegDest = 1;                end                OR: begin                    cuif.ALUOP = ALU_OR;                    cuif.RegWEN = 1;                    cuif.RegDest = 1;                end                XOR: begin                    cuif.ALUOP = ALU_XOR;                    cuif.RegWEN = 1;                    cuif.RegDest = 1;                end                NOR: begin                    cuif.ALUOP = ALU_NOR;                    cuif.RegWEN = 1;                    cuif.RegDest = 1;                end                SLT: begin                    cuif.ALUOP = ALU_SLT;                    cuif.RegWEN = 1;                    cuif.RegDest = 1;                end                SLTU: begin                    cuif.ALUOP = ALU_SLTU;                    cuif.RegWEN = 1;                    cuif.RegDest = 1;                end        endcase        end    //j type        J: begin        cuif.PCSrc = 2&#39;b11;    end    JAL: begin        cuif.PCSrc = 2&#39;b11;        cuif.RegDest = 2&#39;b10;        cuif.RegWEN = 1;            cuif.DataSrc = 2&#39;b11;    end    //itype    BEQ: begin        equFlag = 1;        cuif.ALUOP = ALU_SUB;        cuif.PCSrc = 1;        cuif.branch=cuif.zerFlag &amp; equFlag;    end    BNE: begin        equFlag = 1;        cuif.ALUOP = ALU_SUB;        cuif.PCSrc = 1;        cuif.branch=cuif.zerFlag ^ equFlag;    end            ADDI: begin        cuif.RegWEN=1&#39;b1;        cuif.ALUSrc=2&#39;b11;        cuif.ALUOP=ALU_ADD;        end    ADDIU: begin        cuif.RegWEN=1&#39;b1;        cuif.ALUSrc=2&#39;b11;        cuif.ALUOP=ALU_ADD;        end                ORI: begin        cuif.RegWEN=1&#39;b1;        cuif.ALUSrc=2&#39;b1;        cuif.ALUOP=ALU_OR;        end    XORI: begin         cuif.RegWEN=1&#39;b1;        cuif.ALUSrc=2&#39;b1;        cuif.ALUOP=ALU_XOR;        end        LUI: begin        cuif.RegWEN=1&#39;b1;        cuif.DataSrc=2&#39;b10;    end    LW: begin        cuif.ALUSrc=2&#39;b11;        cuif.memREN=1&#39;b1;        cuif.DataSrc=2&#39;b1;        cuif.ALUOP=ALU_ADD;        cuif.RegWEN=1&#39;b1;    end                SLTI: begin        cuif.RegWEN=1&#39;b1;        cuif.ALUSrc=2&#39;b1;        cuif.ALUOP=ALU_SLT;        end    SLTIU: begin        cuif.RegWEN=1&#39;b1;        cuif.ALUSrc=2&#39;b1;        cuif.ALUOP=ALU_SLTU;    end            ANDI: begin        cuif.RegWEN=1&#39;b1;        cuif.ALUSrc=2&#39;b11;        cuif.ALUOP=ALU_AND;            end    SW: begin        cuif.ALUSrc=2&#39;b11;        cuif.memWEN=1&#39;b1;        cuif.DataSrc=2&#39;b1;        cuif.ALUOP=ALU_ADD;        cuif.RegWEN=1&#39;b0;    end                            HALT: begin        cuif.halt=1&#39;b1;    endendcaseendendmodule            </code></pre><p>`</p><h5 id="接口代码control-unit-if-vh"><a href="#接口代码control-unit-if-vh" class="headerlink" title="接口代码control_unit_if.vh"></a>接口代码control_unit_if.vh</h5><p>这次输入输出信号非常的多，所以写了接口代码。</p><pre><code class="verilog">`ifndef CONTROL_UNIT_IF_VH`define CONTROL_UNIT_IF_VH// typedefs`include &quot;cpu_types_pkg.vh&quot;interface control_unit_if;  // import types  import cpu_types_pkg::*;        opcode_t opcode;    funct_t  funct;    logic [1:0] PCSrc,DataSrc,ALUSrc,RegDest;    logic memREN, memWEN, RegWEN, halt, zerFlag, branch, dhit, ihit;        logic [3:0] ALUOP;modport ctr (    input opcode, funct, zerFlag,dhit,ihit,    output PCSrc,DataSrc,ALUSrc, memREN, memWEN, RegWEN, ALUOP, RegDest, halt, branch    );modport tb (    input PCSrc,DataSrc,ALUSrc, memREN, memWEN, RegWEN, ALUOP, RegDest, halt, branch,    output opcode, funct, zerFlag, dhit);endinterface`endif</code></pre><h5 id="接口代码control-unit-tb-sv"><a href="#接口代码control-unit-tb-sv" class="headerlink" title="接口代码control_unit_tb.sv"></a>接口代码control_unit_tb.sv</h5><p>这次测试代码按照规范一个个写了assert来验证，但是很奇怪有些的assert就是对不上。</p><pre><code class="verilog">`include &quot;control_unit_if.vh&quot;`include &quot;cpu_types_pkg.vh&quot;`timescale 1 ns / 1 nsimport cpu_types_pkg::*;module control_unit_tb;      parameter PERIOD = 10;      logic CLK = 0, nRST;      // clock    always #(PERIOD/2) CLK++;    //interface    control_unit_if cuif();    test21 prog(CLK,nRst,cuif);     //test program    //test PROG (CLK, nRST, cuif);`ifndef MAPPED    control_unit DUT(cuif);`endifendmoduleprogram test21 (input logic CLK,           output logic nRST,          control_unit_if.tb cuif);int testcase =0;initial begin    cuif.opcode=RTYPE;    cuif.funct=SLLV;    cuif.zerFlag=1&#39;b0;    //test reset    @(posedge CLK)    testcase++;//test J type    cuif.opcode=J;//J    //cuif.funct=SLLV;    cuif.zerFlag=1&#39;b0;        @(posedge CLK)    assert (cuif.PCSrc == 2&#39;b11)else  $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);    @(posedge CLK)    testcase++;//test JAL type        cuif.opcode=JAL;//JAL    //cuif.funct=&#39;0;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert (cuif.PCSrc == 2&#39;b11 &amp;&amp; cuif.RegDest == 2&#39;b10 &amp;&amp; cuif.RegWEN == 1 &amp;&amp; cuif.DataSrc == 2&#39;b11) else $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);    @(posedge CLK)    testcase++;//test itype        cuif.opcode=BEQ;//BEQ    //cuif.funct=&#39;0;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert ( cuif.PCSrc == 1 &amp;&amp; cuif.branch == 0) else $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);    @(posedge CLK)    testcase++;//test itype        cuif.opcode=BNE;//BNE    //cuif.funct=&#39;0;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert ( cuif.PCSrc == 1 &amp;&amp; cuif.branch==1) else $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);    @(posedge CLK)    testcase++;//test itype        cuif.opcode=ADDI;//ADDI    //cuif.funct=&#39;0;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert (cuif.RegWEN==1&#39;b1 &amp;&amp; cuif.ALUSrc==2&#39;b1) else $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);    @(posedge CLK)    testcase++;//test itype        cuif.opcode=ANDI;//ANDI    //cuif.funct=&#39;0;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert ( cuif.RegWEN==1&#39;b1 &amp;&amp; cuif.ALUSrc==2&#39;b11) else $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);    @(posedge CLK)    testcase++;//test itype        cuif.opcode=ORI;//ORI    //cuif.funct=&#39;0;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert ( cuif.RegWEN==1&#39;b1 &amp;&amp; cuif.ALUSrc==2&#39;b11)else $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);    @(posedge CLK)            testcase++;//test itype        cuif.opcode=LUI;//LUI    //cuif.funct=&#39;0;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert (cuif.RegWEN==1&#39;b1 &amp;&amp; cuif.DataSrc==2&#39;b10) else $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);    @(posedge CLK)    testcase++;//test itype        cuif.opcode=HALT;//HALT    //cuif.funct=&#39;0;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert (cuif.halt==1&#39;b1)  else $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);        @(posedge CLK)    testcase++;//test Rtype        cuif.funct=SLLV;//SLL    cuif.opcode=RTYPE;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert ( cuif.RegWEN == 1 &amp;&amp; cuif.RegDest == 1 &amp;&amp; cuif.ALUSrc == 2&#39;b10)else $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);        @(posedge CLK)    testcase++;//test Rtype        cuif.funct=SRLV;//SLL    cuif.opcode=RTYPE;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert ( cuif.RegWEN ==1 &amp;&amp; cuif.RegDest == 1)else $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);        @(posedge CLK)    testcase++;//test Rtype        cuif.funct=ADD;//SLL    cuif.opcode=RTYPE;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert ( cuif.RegWEN == 1 &amp;&amp; cuif.RegDest == 1 )else $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);        @(posedge CLK)    testcase++;//test Rtype        cuif.funct=ADDU;//SLL    cuif.opcode=RTYPE;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert ( cuif.RegWEN == 1 &amp;&amp; cuif.RegDest == 1 )else $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);        @(posedge CLK)    testcase++;//test Rtype        cuif.funct=SUBU;//SLL    cuif.opcode=RTYPE;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert ( cuif.RegWEN == 1 )else $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);        @(posedge CLK)    testcase++;//test Rtype        cuif.funct=SUB;//SLL    cuif.opcode=RTYPE;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert ( cuif.RegWEN == 1 )else $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);        @(posedge CLK)    testcase++;//test Rtype        cuif.funct=AND;//SLL    cuif.opcode=RTYPE;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert ( cuif.RegWEN == 1 )else $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);        @(posedge CLK)    testcase++;//test Rtype        cuif.funct=OR;//SLL    cuif.opcode=RTYPE;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert ( cuif.RegWEN == 1 &amp;&amp; cuif.RegDest == 1 )else $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);        @(posedge CLK)    testcase++;//test Rtype        cuif.funct=XOR;//SLL    cuif.opcode=RTYPE;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert ( cuif.RegWEN == 1 &amp;&amp; cuif.RegDest == 1 )  $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);        @(posedge CLK)    testcase++;//test Rtype        cuif.funct=NOR;//SLL    cuif.opcode=RTYPE;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert ( cuif.RegWEN == 1 &amp;&amp; cuif.RegDest == 1 ) else $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);        @(posedge CLK)    testcase++;//test Rtype        cuif.funct=SLT;//SLL    cuif.opcode=RTYPE;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert ( cuif.RegWEN == 1 &amp;&amp; cuif.RegDest == 1 ) else $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);        @(posedge CLK)    testcase++;//test Rtype        cuif.funct=SLTU;//SLL    cuif.opcode=RTYPE;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    if ( ~(cuif.RegWEN == 1 &amp;&amp; cuif.RegDest == 1 &amp;&amp; cuif.ALUSrc == 2&#39;b10))  $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);        @(posedge CLK)    testcase++;//test Rtype        cuif.funct=JR;//JR    cuif.opcode=RTYPE;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert (cuif.PCSrc == 2&#39;b10)   $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);        @(posedge CLK)    testcase++;//test Rtype        cuif.funct=SUB;//SUB    cuif.opcode=RTYPE;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert (cuif.PCSrc == 2&#39;b1 &amp;&amp; cuif.RegWEN == 1 ) else $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);        @(posedge CLK)    testcase++;//test Rtype        cuif.funct=SUB;//SUB    cuif.opcode=ADDIU;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert (cuif.PCSrc == 2&#39;b1)  $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);        @(posedge CLK)    testcase++;//test Rtype        cuif.funct=SUB;//SUB    cuif.opcode=SLTI;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert (cuif.PCSrc == 2&#39;b1)  $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);        @(posedge CLK)        @(posedge CLK)    testcase++;//test Rtype        cuif.funct=SUB;//SUB    cuif.opcode=SLTIU;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert (cuif.PCSrc == 2&#39;b1) else $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);        @(posedge CLK)        @(posedge CLK)    testcase++;//test Rtype        cuif.funct=SUB;//SUB    cuif.opcode=XORI;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert (cuif.ALUSrc == 2&#39;b11)  $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);        @(posedge CLK)        @(posedge CLK)    testcase++;//test Rtype        cuif.funct=SUB;//SUB    cuif.opcode=LW;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert (cuif.ALUSrc == 2&#39;b11 &amp;&amp;  cuif.DataSrc == 1 )  $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);        @(posedge CLK)    @(posedge CLK)    testcase++;//test Rtype        cuif.funct=SUB;//SUB    cuif.opcode=SW;    cuif.zerFlag=1&#39;b0;    @(posedge CLK)    assert (cuif.ALUSrc == 2&#39;b11 &amp;&amp;  cuif.DataSrc == 1)  $display(&quot;It&#39;s gone wrong addtime %00g ns&quot;,$time);        @(posedge CLK)    cuif.zerFlag=1&#39;b1;    @(posedge CLK)    cuif.zerFlag=1&#39;b0;        @(posedge CLK)    cuif.ihit=1&#39;b0;        cuif.dhit=1&#39;b0;        @(posedge CLK)    cuif.ihit=1&#39;b1;        cuif.dhit=1&#39;b1;    @(posedge CLK)$finish;                   endendprogram</code></pre><p>以上就是控制单元的代码，接下来就会是一个总的单元用于处理所有小的模块和前面写过的模块。</p>]]></content>
      
      
      <categories>
          
          <category> MIPS CPU design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIPS </tag>
            
            <tag> FPGA </tag>
            
            <tag> verilog </tag>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>singlecycle设计及实现2 (ALU算术逻辑单元)</title>
      <link href="/2020/03/21/singlecycle-alu/"/>
      <url>/2020/03/21/singlecycle-alu/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这篇博文主要介绍的是基于mips的 singlecycle CPU设计及实现的第二个单元ALU算术逻辑单元。</p><span id="more"></span><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><p><img src="https://res.cloudinary.com/djyodckal/image/upload/v1584759605/datapath_jchv0c.png"><br>衔接上篇的寄存器的讨论，这次将对ALU算术逻辑单元进行编写。mips支持的指令有很多指令形式(instruction format)，如<br>R-type：Op, rs, rt, rd 单纯只用到了寄存器的值，<br>I-type：OP rt, IMM(rs) 或 OP  rs, rt, IMM 用到了立即值，(这里的立即值是16位)<br>J-type：Op, address 用到了地址。(这里的地址是26位)。<br>为什么要进行分类呢，因为根据不同的类型，ALU 算术逻辑单元的数据总线的值可能会有不同。<br>例如：<br>R-type ADD：bus1 就是rt, bus2 就是rd<br>I-type LD：     bus1 就是rs, bus2就是 IMM<br>I-type BEQ：  bus1 就是rs, bus2就是 IMM(减法判断结果是不是0)<br>j-type JAL：   不需要ALU，PC单元能够单独解决。</p><p>算术逻辑单元只能实现一些比较简单的算术，但是mips却支持很多的指令。因为这些复杂的指令可以通过简单的逻辑算术和别的模块解决。</p><p>但是为什么不能直接根据opcode直接进行运算，像 opcode == add 把rt + rd的值放入rs。直接把多个模块需要合作解决的和在一起。 因为通过简单的逻辑指令和别的模块的合作，能灵活的实现复杂的指令，最重要的是能省下不少晶体管。</p><p>那为什么算术逻辑单元的输出还有负数符号，溢出符号。但是在总的singlecycle CPU设计上没有这些输出信号，因为mips不关心溢出和负数符号，但是零符号是需要用来检测分支的。</p><h4 id="ALU-算术逻辑单元"><a href="#ALU-算术逻辑单元" class="headerlink" title="ALU 算术逻辑单元"></a>ALU 算术逻辑单元</h4><p><img src="https://res.cloudinary.com/djyodckal/image/upload/v1584871537/lab2__1_uwlege.png"><br>如图所示上图展示了算术逻辑单元的一些输入及输出。<br>输入:<br>PortA(31:0) 32位的bus1输入<br>PortB(31:0) 32位的bus2输入<br>ALUOP(3:0) 算术逻辑单元指令选择<br>输出:<br>Negative 负符号<br>Overflow 溢出符号<br>Zero 零符号<br>Output Port(31:0) 算术逻辑单元输出</p><p>这次因为接口比较少，所以偷了懒没有写接口文件，但是写了FPGA文件。</p><h5 id="主代码alu-sv"><a href="#主代码alu-sv" class="headerlink" title="主代码alu.sv"></a>主代码alu.sv</h5><pre><code class="verilog">   `include &quot;cpu_types_pkg.vh&quot;   module alu   (       input logic [31:0] portA,       input logic [31:0] portB,       input logic [3:0] aluOP,       output logic negFlag,       output logic oveFlag,       output logic zerFlag,       output logic [31:0] outputPort   );   import cpu_types_pkg::*;   always_comb begin       negFlag = 0;       oveFlag = 0;       zerFlag = 0;       outputPort = &#39;0;       if (aluOP == ALU_SLL)//向左移           outputPort =  portB &lt;&lt; portA;       else if (aluOP == ALU_SRL))//向右移           outputPort =  portB &gt;&gt; portA;       else if (aluOP == ALU_ADD) begin)//加           outputPort = portA + portB;           if (outputPort[31] != (portA[31] ^ portB[31]))               oveFlag = 1;           end       else if (aluOP == ALU_SUB) begin//减           outputPort = portA - portB;           if (outputPort[31] != (portA[31] ^ portB[31]))               oveFlag = 1;           end       else if (aluOP == ALU_AND)//和           outputPort = portA &amp; portB;       else if (aluOP == ALU_OR)//或           outputPort = portA | portB;       else if (aluOP == ALU_XOR)//异或           outputPort = portA ^ portB;       else if (aluOP == ALU_NOR)//非或           outputPort = ~(portA | portB);       else if (aluOP == ALU_SLTU)//小于不考虑符号           outputPort = portA &lt; portB;       else if (aluOP == ALU_SLT) begin//小于考虑符号 这段代码应该写错了 最后评分就这段没过测试           if (portA[31] == 1 &amp;&amp; portB[31] == 0)               outputPort = 1;           else if (portA[31] == 0 &amp;&amp; portB[31] == 1)               outputPort = 0;           else               outputPort = portA &lt; portB;       end    //单独判断零和负符号       if (outputPort == 0)           zerFlag = 1;       if (outputPort[31] == 1)           negFlag = 1;       end   endmodule   </code></pre><p>这次测试代码直接用最简单粗暴的方式测试了，但是覆盖率还是100%。(根据questasim的report判断的)</p><h5 id="测试代码alu-tb-sv"><a href="#测试代码alu-tb-sv" class="headerlink" title="测试代码alu_tb.sv"></a>测试代码alu_tb.sv</h5><pre><code class="verilog">    `include &quot;cpu_types_pkg.vh&quot;    // mapped timing needs this. 1ns is too fast    `timescale 1 ns / 1 ns    module alu_tb();          parameter PERIOD = 10;          logic CLK = 0, nRST;          logic [31:0] portA;      logic [31:0] portB;      logic [3:0] aluOP;      logic negFlag;      logic oveFlag;      logic zerFlag;      logic [3:0] i;      logic [31:0] outputPort;      always #(PERIOD/2) CLK++;          import cpu_types_pkg::*;      // test program      //test PROG (portA,portB,aluOP,negFlag,oveFlag,negFlag,zerFlag,outputPort);      // DUT           alu DUT(portA,portB,aluOP,negFlag,oveFlag,zerFlag,outputPort);      initial begin        portA = &#39;0;        portB = &#39;0;        aluOP = &#39;0;            for (i = 0; i &lt; 14; i = i + 1) begin        @(posedge CLK)        portA = &#39;1;        portB = &#39;1;        aluOP = i;                @(posedge CLK)        portA = 0;        portB = 0;        aluOP = i;                @(posedge CLK)        portA = 1;        portB = 0;        aluOP = i;            @(posedge CLK)        portA = 0;        portB = 1;        aluOP = i;            @(posedge CLK)        portA = &#39;0;        portB = &#39;0;        aluOP = i;                                end            @(posedge CLK)        portA = &#39;0;        portB = &#39;0;        aluOP = &#39;1;        @(posedge CLK)        portA = &#39;0;        portB = &#39;0;        aluOP = 0;        @(posedge CLK)                    $stop;        end    endmodule            </code></pre><h5 id="FPGA代码alu-fpga-sv"><a href="#FPGA代码alu-fpga-sv" class="headerlink" title="FPGA代码alu_fpga.sv"></a>FPGA代码alu_fpga.sv</h5><pre><code class="verilog">    /*      Eric Villasenor          register file fpga wrapper    */        // interface    `include &quot;cpu_types_pkg.vh&quot;        module alu_fpga (      input logic CLOCK_50,      input logic [3:0] KEY,      input logic [17:0] SW,      output logic [17:0] LEDR,      output logic [6:0]  HEX0,      output logic [6:0]  HEX1,      output logic [6:0]  HEX2,      output logic [6:0]  HEX3    );        import cpu_types_pkg::*;        logic negFlag;        logic oveFlag;        logic zerFlag;        logic [31:0] output1;        reg [31:0] register;        reg [31:0] nregister;        logic [31:0] portA;        assign portA = &#123;16*&#123;SW[16]&#125;,SW[15:0]&#125;;        always_ff @(posedge CLOCK_50) begin            if (SW[17])                register &lt;= &#123;16*&#123;SW[16]&#125;,SW[15:0]&#125;;            else                register &lt;= register;        end                alu DUT(.portA(portA),.portB(register),.aluOP(~KEY),.negFlag(negFlag),.oveFlag(oveFlag),.zerFlag(zerFlag),.outputPort(output1));//map 版本            always_comb        begin         unique casez (output1[3:0])//led显示设置          &#39;h0: HEX0 = 7&#39;b1000000;          &#39;h1: HEX0 = 7&#39;b1111001;          &#39;h2: HEX0 = 7&#39;b0100100;          &#39;h3: HEX0 = 7&#39;b0110000;          &#39;h4: HEX0 = 7&#39;b0011001;          &#39;h5: HEX0 = 7&#39;b0010010;          &#39;h6: HEX0 = 7&#39;b0000010;          &#39;h7: HEX0 = 7&#39;b1111000;          &#39;h8: HEX0 = 7&#39;b0000000;          &#39;h9: HEX0 = 7&#39;b0010000;          &#39;ha: HEX0 = 7&#39;b0001000;          &#39;hb: HEX0 = 7&#39;b0000011;          &#39;hc: HEX0 = 7&#39;b0100111;          &#39;hd: HEX0 = 7&#39;b0100001;          &#39;he: HEX0 = 7&#39;b0000110;          &#39;hf: HEX0 = 7&#39;b0001110;        default: HEX0 = 7&#39;b1000000; // &quot;0&quot;          endcase             unique casez (output1[7:4])          &#39;h0: HEX1 = 7&#39;b1000000;          &#39;h1: HEX1 = 7&#39;b1111001;          &#39;h2: HEX1 = 7&#39;b0100100;          &#39;h3: HEX1 = 7&#39;b0110000;          &#39;h4: HEX1 = 7&#39;b0011001;          &#39;h5: HEX1 = 7&#39;b0010010;          &#39;h6: HEX1 = 7&#39;b0000010;          &#39;h7: HEX1 = 7&#39;b1111000;          &#39;h8: HEX1 = 7&#39;b0000000;          &#39;h9: HEX1 = 7&#39;b0010000;          &#39;ha: HEX1 = 7&#39;b0001000;          &#39;hb: HEX1 = 7&#39;b0000011;          &#39;hc: HEX1 = 7&#39;b0100111;          &#39;hd: HEX1 = 7&#39;b0100001;          &#39;he: HEX1 = 7&#39;b0000110;          &#39;hf: HEX1 = 7&#39;b0001110;        default: HEX1 = 7&#39;b1000000; // &quot;0&quot;          endcase             unique casez (output1[11:8])          &#39;h0: HEX2 = 7&#39;b1000000;          &#39;h1: HEX2 = 7&#39;b1111001;          &#39;h2: HEX2 = 7&#39;b0100100;          &#39;h3: HEX2 = 7&#39;b0110000;          &#39;h4: HEX2 = 7&#39;b0011001;          &#39;h5: HEX2 = 7&#39;b0010010;          &#39;h6: HEX2 = 7&#39;b0000010;          &#39;h7: HEX2 = 7&#39;b1111000;          &#39;h8: HEX2 = 7&#39;b0000000;          &#39;h9: HEX2 = 7&#39;b0010000;          &#39;ha: HEX2 = 7&#39;b0001000;          &#39;hb: HEX2 = 7&#39;b0000011;          &#39;hc: HEX2 = 7&#39;b0100111;          &#39;hd: HEX2 = 7&#39;b0100001;          &#39;he: HEX2 = 7&#39;b0000110;          &#39;hf: HEX2 = 7&#39;b0001110;        default: HEX2 = 7&#39;b1000000; // &quot;0&quot;          endcase             unique case(output1[15:12])          &#39;h0: HEX3 = 7&#39;b1000000;          &#39;h1: HEX3 = 7&#39;b1111001;          &#39;h2: HEX3 = 7&#39;b0100100;          &#39;h3: HEX3 = 7&#39;b0110000;          &#39;h4: HEX3 = 7&#39;b0011001;          &#39;h5: HEX3 = 7&#39;b0010010;          &#39;h6: HEX3 = 7&#39;b0000010;          &#39;h7: HEX3 = 7&#39;b1111000;          &#39;h8: HEX3 = 7&#39;b0000000;          &#39;h9: HEX3 = 7&#39;b0010000;          &#39;ha: HEX3 = 7&#39;b0001000;          &#39;hb: HEX3 = 7&#39;b0000011;          &#39;hc: HEX3 = 7&#39;b0100111;          &#39;hd: HEX3 = 7&#39;b0100001;          &#39;he: HEX3 = 7&#39;b0000110;          &#39;hf: HEX3 = 7&#39;b0001110;        default: HEX3 = 7&#39;b1000000; // &quot;0&quot;          endcase        end        assign LEDR[17:14] = portA[3:0];        assign LEDR[13:10] = register[3:0];    assign LEDR[0] = negFlag;    assign LEDR[1] = oveFlag;    assign LEDR[2] = zerFlag;                endmodule    </code></pre><p>借此alu逻辑算术单元也算完成了。</p>]]></content>
      
      
      <categories>
          
          <category> MIPS CPU design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIPS </tag>
            
            <tag> FPGA </tag>
            
            <tag> verilog </tag>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>singlecycle设计及实现1(register file寄存器)</title>
      <link href="/2020/03/20/singlecycle_rf/"/>
      <url>/2020/03/20/singlecycle_rf/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这篇博文主要介绍的是基于mips的 singlecycle CPU设计及实现。</p><span id="more"></span><h3 id="RTL-图像"><a href="#RTL-图像" class="headerlink" title="RTL 图像"></a>RTL 图像</h3><p><img src="https://res.cloudinary.com/djyodckal/image/upload/v1584759605/datapath_jchv0c.png"><br>因为刚开始写的时候只考虑了mips最基础的指令，没有考虑lui和跳转等指令，所以这是一个非常粗略的图像。主要由几个大块组成，register file寄存器，ALU算术逻辑单元，memory储存，control unit控制单元，instruction fetch指令获取单元，PC 程序计数器和decoder。由于decoder已经编写，所以这次设计直接从储存中读取opcode来识别指令，iload来识别各个寄存器的地址。接下来一一介绍每个单元。</p><h4 id="register-file-寄存器"><a href="#register-file-寄存器" class="headerlink" title="register file 寄存器"></a>register file 寄存器</h4><p><img src="https://res.cloudinary.com/djyodckal/image/upload/v1584760463/registerDiagram_djizyf.png"><br>如图所示上图展示了寄存器的一些输入及输出。<br>输入:<br>WDAT(31:0) 32位的输入<br>WSEL(4:0) 寄存器地址选择<br>WEN 寄存器开关 1:开 0:关<br>CLK 寄存器时钟<br>RSEL1(4:0) 数据总线1 地址选择<br>RSEL2(4:0) 数据总线2 地址选择<br>输出:<br>RDAT1(31:0) 数据总线1值<br>RDAT2(31:0) 数据总线2值</p><p>以前写verilog代码的时候，并没有用过接口，这次因为是要求，所以更具接口的方式来编写。</p><h5 id="主代码register-file-sv"><a href="#主代码register-file-sv" class="headerlink" title="主代码register_file.sv"></a>主代码register_file.sv</h5><pre><code class="verilog">    `include &quot;cpu_types_pkg.vh”//cpu总接口文件    `include &quot;register_file_if.vh”//寄存器接口文件    module register_file        (    input logic CLK, nRST,    register_file_if.rf rfif//接口中 rf端口    );        //mips有32个32位的寄存器，并且需要放入reg    reg [31:0][31:0] register;//输出的寄存器    reg [31:0][31:0] nregister;//输入的寄存器    always_comb begin    nregister = register;    if (rfif.WEN &amp;&amp; rfif.wsel != 0) begin//mips 0寄存器不能修改并且要在打开的情况才能修改        nregister[rfif.wsel] = rfif.wdat;    end    rfif.rdat1 = register[rfif.rsel1];    rfif.rdat2 = register[rfif.rsel2];       end        always_ff @(posedge CLK, negedge nRST) begin//异步同步    if (!nRST)        register &lt;= &#39;0;    else        register &lt;= nregister;    end        endmodule</code></pre><h5 id="接口代码register-file-if-vh"><a href="#接口代码register-file-if-vh" class="headerlink" title="接口代码register_file_if.vh"></a>接口代码register_file_if.vh</h5><pre><code class="verilog">/* Eric Villasenor register file interface*/`ifndef REGISTER_FILE_IF_VH`define REGISTER_FILE_IF_VH// all types`include &quot;cpu_types_pkg.vh&quot;interface register_file_if; // import types import cpu_types_pkg::*; logic     WEN; regbits_t wsel, rsel1, rsel2;//在cpu_types_pkg.vh中定义 5，2^5 = 32 word_t    wdat, rdat1, rdat2;//在cpu_types_pkg.vh中定义32 // register file ports modport rf (   input   WEN, wsel, rsel1, rsel2, wdat,   output  rdat1, rdat2 ); // register file tb modport tb (   input   rdat1, rdat2,   output  WEN, wsel, rsel1, rsel2, wdat );endinterface`endif //REGISTER_FILE_IF_VH</code></pre><p>`</p><h5 id="测试代码register-file-tb-sv"><a href="#测试代码register-file-tb-sv" class="headerlink" title="测试代码register_file_tb.sv"></a>测试代码register_file_tb.sv</h5><pre><code class="verilog">    \*     Eric Villasenor         register file test bench    */        // mapped needs this    `include &quot;register_file_if.vh&quot;        // mapped timing needs this. 1ns is too fast    `timescale 1 ns / 1 ns        module register_file_tb;         parameter PERIOD = 10;         logic CLK = 0, nRST;         // test vars     int v1 = 1;     int v2 = 4721;     int v3 = 25119;         // clock     always #(PERIOD/2) CLK++;         // interface     register_file_if rfif ();     // test program     test PROG (CLK, nRST,rfif,v1,v2,v3);     // DUT    `ifndef MAPPED     register_file DUT(CLK, nRST, rfif);    `else     register_file DUT(    .rfif.rdat2 (rfif.rdat2),    .rfif.rdat1 (rfif.rdat1),    .rfif.wdat (rfif.wdat),    .rfif.rsel2 (rfif.rsel2),    .rfif.rsel1 (rfif.rsel1),    .rfif.wsel (rfif.wsel),    .rfif.WEN (rfif.WEN),    .nRST (nRST),    .CLK (CLK)     );    `endif        endmodule        program test    (    input logic CLK,    output logic nRST,        register_file_if.tb rfif,    input logic [31:0] v1,    input logic [31:0] v2,    input logic [31:0] v3    );    reg [5:0] i;    reg [3:0] testcase = 0;    initial begin    rfif.wsel = 0;    rfif.wdat = &#39;0;    rfif.WEN = 0;    rfif.rsel1 = 0;    rfif.rsel2 = 0;          @(posedge CLK)    nRST = 1&#39;b0;            @(posedge CLK)    nRST = 1&#39;b0;        @(posedge CLK)    nRST = 1&#39;b1;    rfif.wsel = 0;    rfif.WEN = 1;    rfif.wdat = &#39;1;    rfif.rsel1 = 0;    rfif.rsel2 = 1;    testcase ++;    @(posedge CLK)    nRST = 1&#39;b0;    @(posedge CLK)    nRST = 1&#39;b1;    for (i = 0; i &lt; 32; i = i + 1)    begin        @(posedge CLK)        rfif.wsel = i;        @(posedge CLK)        rfif.rsel1 = i;        rfif.rsel2 = 31-i;    end    @(posedge CLK)    nRST = 1&#39;b1;    rfif.wsel = 1;    rfif.WEN = 1;    rfif.wdat = &#39;0;    rfif.rsel1 = 0;    rfif.rsel2 = 1;    testcase ++;    @(posedge CLK)    nRST = 1&#39;b0;    @(posedge CLK)    nRST = 1&#39;b1;    for (i = 0; i &lt; 32; i = i + 1)    begin        @(posedge CLK)        rfif.wsel = i;        @(posedge CLK)        rfif.rsel1 = i;        rfif.rsel2 = 31-i;    end    @(posedge CLK)    nRST = 1&#39;b0;    @(posedge CLK)    nRST = 1&#39;b1;    rfif.wsel = 1;    rfif.WEN = 1;    rfif.wdat = &#39;1;    rfif.rsel1 = 1;    rfif.rsel2 = 0;    testcase ++;    @(posedge CLK)    nRST = 1&#39;b0;    @(posedge CLK)    nRST = 1&#39;b1;    for (i = 0; i &lt; 32; i = i + 1)    begin        @(posedge CLK)        rfif.wsel = i;        @(posedge CLK)        rfif.rsel1 = i;        rfif.rsel2 = 31-i;    end    @(posedge CLK)    @(posedge CLK)    nRST = 1&#39;b0;    @(posedge CLK)    @(posedge CLK)    $finish;    end    endprogram</code></pre><p>测试文件用questasim来验证，本来应该用assert更规范的测试，第一次懒惰了。<br> 以上是singlecycle中寄存器文件的</p>]]></content>
      
      
      
        <tags>
            
            <tag> MIPS </tag>
            
            <tag> FPGA </tag>
            
            <tag> verilog </tag>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python douyu 礼物统计</title>
      <link href="/2019/12/20/liwu/"/>
      <url>/2019/12/20/liwu/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>最近看有主播进行礼物的手动统计，感觉实在是有点费功夫于是尝试提升效率。首先在下实在不熟悉API，并且TCP了解的也比较肤浅，所以打算更具每次直播聊天的文本进行提取信息来统计礼物数。</p><span id="more"></span><h2 id="具体实践顺序"><a href="#具体实践顺序" class="headerlink" title="具体实践顺序"></a>具体实践顺序</h2><h3 id="1-查看文本格式"><a href="#1-查看文本格式" class="headerlink" title="1. 查看文本格式"></a>1. 查看文本格式</h3><p><img src="https://res.cloudinary.com/djyodckal/image/upload/v1576809787/31576809495_.pic_hd_nhzean.png"><br>格式如上所示。由于直播方正好开了礼物感谢的方式，每一次收礼物都能进行文本抓取。<br>但是里面有一些比较特殊的礼物格式，例如下图。<br><img src="https://res.cloudinary.com/djyodckal/image/upload/v1576810007/41576809989_.pic_hd_izzax5.jpg"><br>由于送礼物会出现连击的现象，在短时间内送出多个相同的礼物会出现连击的效果。其实只有六次而不是1+2+…+6次。但是又不能根据每一次连击效果进行简单的礼物数加一，因为存在一次性送礼物，并且不同的礼物类型会有不同的选项。</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>如果能赠送办卡会有如下的选项。<br><img src="https://res.cloudinary.com/djyodckal/image/upload/v1576810240/61576810220_.pic_xt0x06.jpg"><br>x10，x66, x366,x520,x1314等选项。<br>所以存在一次叠加超过一次的情况。</p><h3 id="2-查看需要抓取的格式"><a href="#2-查看需要抓取的格式" class="headerlink" title="2. 查看需要抓取的格式"></a>2. 查看需要抓取的格式</h3><p>根据前面几幅图，礼物送出后有如下体现。<br>【主播 ID】： 感谢。【送礼者ID】  送出的 【礼物类型】x【数量】<br>就可以根据简单的正则表达式进行抓取。但是由于是中文的原因，折腾了一个小时，包括文本log文件的转码（因为在mac上显示全是乱码），包括正则表达式中的乱码，最后还包括送礼者ID的群魔乱舞，可能包含各种特殊符号或文字。</p><h3 id="3-完整编码"><a href="#3-完整编码" class="headerlink" title="3. 完整编码"></a>3. 完整编码</h3><p>完整代码如下</p><pre><code class="python">    import re    import os    import time    import codecs    def find\_liwu():    filename = os.listdir(&#39;logfile&#39;)    filepath = []    for element in filename:        if len(element.split(&#39;.txt&#39;)) &gt;= 2:            #print element            filepath.append(element)    feiji = &#39;飞机&#39;    banka = &#39;办卡&#39;    i = 0    bankadic = &#123;&#125;    feijidic = &#123;&#125;    g = 0    num = [0]    patternbanka = unicode(&#39;感谢 &#39;,&#39;utf8&#39;,errors=&#39;ignore&#39;)+u&#39;[\u4e00-\u9fa5\d\w]+&#39;+unicode(&#39; 送出的 &#39;,&#39;utf8&#39;,errors=&#39;ignore&#39;)+unicode(banka,&#39;utf8&#39;,errors=&#39;ignore&#39;)+&#39;[x][\d]+&#39;    patternfeiji = unicode(&#39;感谢 &#39;, &#39;utf8&#39;, errors=&#39;ignore&#39;) + u&#39;[\u4e00-\u9fa5\d\w]+&#39; + unicode(&#39; 送出的 &#39;, &#39;utf8&#39;,errors=&#39;ignore&#39;) + unicode(feiji, &#39;utf8&#39;, errors=&#39;ignore&#39;) + &#39;[x][\d]+&#39;    while i &lt; len(filepath):        path = &#39;logfile/&#39; + filepath[i]        with open(path) as f:            loglines = f.read().splitlines()        j = 0            while j &lt; len(loglines):            line = unicode(loglines[j], &quot;utf8&quot;, errors=&quot;ignore&quot;)            answer = re.findall(patternbanka,line)            answer1 = re.findall(patternfeiji,line)            #print(answer)            if answer:                #print len(answer)                g += 1                #print(answer[0])                prev = int(num[0])                patternName = u&#39;(?P&lt;name&gt;[\u4e00-\u9fa5\d\w]+)&#39;+unicode(&#39; 送出的 &#39;,&#39;utf8&#39;,errors=&#39;ignore&#39;)                name = re.findall(patternName,answer[0])                patternNum = unicode(banka,&#39;utf8&#39;,errors=&#39;ignore&#39;)+&#39;[x](?P&lt;num&gt;[\d]+)&#39;                num = re.findall(patternNum,answer[0])                num1 = int(num[0])                #print name[0], num1, prev                if name[0] in bankadic.keys():                    if num1 == 1:                        bankadic[name[0]] = bankadic[name[0]] + 1                    elif num1 == 10 and prev != 9:                        bankadic[name[0]] = bankadic[name[0]] + 10                    elif num1 == 66 and prev != 65:                        bankadic[name[0]] = bankadic[name[0]] + 66                    elif num1 == 366 and prev != 365:                        bankadic[name[0]] = bankadic[name[0]] + 366                    elif num1 == 520 and prev != 519:                        bankadic[name[0]] = bankadic[name[0]] + 520                    elif num1 == 1314 and prev != 1313:                        bankadic[name[0]] = bankadic[name[0]] + 1314                    else:                        bankadic[name[0]] = bankadic[name[0]] + 1                else:                    bankadic[name[0]] = num1            if answer1:                #print len(answer)                g += 1                #print(answer[0])                prev = int(num[0])                patternName = u&#39;(?P&lt;name&gt;[\u4e00-\u9fa5\d\w]+)&#39;+unicode(&#39; 送出的 &#39;,&#39;utf8&#39;,errors=&#39;ignore&#39;)                name = re.findall(patternName,answer1[0])                patternNum = unicode(feiji,&#39;utf8&#39;,errors=&#39;ignore&#39;)+&#39;[x](?P&lt;num&gt;[\d]+)&#39;                num = re.findall(patternNum,answer1[0])                num1 = int(num[0])                #print name[0], num1, prev                if name[0] in feijidic.keys():                    if num1 == 1:                        feijidic[name[0]] = feijidic[name[0]] + 1                    elif num1 == 10 and prev != 9:                        feijidic[name[0]] = feijidic[name[0]] + 10                    elif num1 == 66 and prev != 65:                        feijidic[name[0]] = feijidic[name[0]] + 66                    elif num1 == 366 and prev != 365:                        feijidic[name[0]] = feijidic[name[0]] + 366                    elif num1 == 520 and prev != 519:                        feijidic[name[0]] = feijidic[name[0]] + 520                    elif num1 == 1314 and prev != 1313:                        feijidic[name[0]] = feijidic[name[0]] + 1314                    else:                        feijidic[name[0]] = feijidic[name[0]] + 1                else:                    feijidic[name[0]] = num1            j+= 1        i += 1    #print bankadic.keys()[1], bankadic[bankadic.keys()[1]]    #print feijidic    f = codecs.open(&#39;liwu.txt&#39;,&#39;w&#39;,&#39;utf-8&#39;)    #print bankadic.keys()[0]    i = 0    while i &lt; (len(bankadic)):        if bankadic.keys()[i] in feijidic.keys():            f.write(bankadic.keys()[i] + &#39; &#39;+ str(bankadic[bankadic.keys()[i]])+unicode(&#39; 办卡 &#39;,&#39;utf8&#39;,errors=&#39;ignore&#39;)+ str(feijidic[bankadic.keys()[i]])+ unicode(&#39; 飞机&#39;,&#39;utf8&#39;,errors=&#39;ignore&#39;) +unicode(&#39; 价值 &#39;,&#39;utf8&#39;,errors=&#39;ignore&#39;)+ str(bankadic[bankadic.keys()[i]]*6+feijidic[bankadic.keys()[i]]*100)+ &#39; &#39;&#39;\n&#39;)        else:            f.write(bankadic.keys()[i] + &#39; &#39;+ str(bankadic[bankadic.keys()[i]])+unicode(&#39; 办卡&#39;,&#39;utf8&#39;,errors=&#39;ignore&#39;)+  unicode(&#39; 0  飞机&#39;,&#39;utf8&#39;,errors=&#39;ignore&#39;)+unicode(&#39; 价值 &#39;,&#39;utf8&#39;,errors=&#39;ignore&#39;)+ str(bankadic[bankadic.keys()[i]]*6) +&#39;\n&#39;)        i += 1    i = 0    while i &lt; (len(feijidic)):        if feijidic.keys()[i] in bankadic.keys():            f.write(feijidic.keys()[i] + &#39; &#39;+ str(bankadic[feijidic.keys()[i]])+ unicode(&#39; 办卡 &#39;,&#39;utf8&#39;,errors=&#39;ignore&#39;)+ str(feijidic[feijidic.keys()[i]])+unicode(&#39; 飞机 &#39;,&#39;utf8&#39;,errors=&#39;ignore&#39;) +unicode(&#39; 价值 &#39;,&#39;utf8&#39;,errors=&#39;ignore&#39;)+ str(bankadic[feijidic.keys()[i]]*6+feijidic[feijidic.keys()[i]]*100)+&#39;\n&#39;)        else:            f.write(feijidic.keys()[i] + &#39; &#39;+ unicode(&#39; 0 办卡 &#39;,&#39;utf8&#39;,errors=&#39;ignore&#39;)+ str(feijidic[feijidic.keys()[i]])+unicode(&#39; 飞机&#39;,&#39;utf8&#39;,errors=&#39;ignore&#39;)  +unicode(&#39; 价值 &#39;,&#39;utf8&#39;,errors=&#39;ignore&#39;)+ str(feijidic[feijidic.keys()[i]]*100) +&#39;\n&#39;)        i += 1     if __name__ == &quot;__main__&quot;:    start_time = time.time()    a = find_liwu()    #a = &#39;x5&#39;    #pattern = r&#39;[x][\d]&#39;    #a2=re.findall(pattern,a)                    print(&quot;--- %s seconds ---&quot; % (time.time() - start_time))    filename = os.listdir(&#39;logfile&#39;)</code></pre><h4 id="4-结果输出"><a href="#4-结果输出" class="headerlink" title="4. 结果输出"></a>4. 结果输出</h4><p><img src="https://res.cloudinary.com/djyodckal/image/upload/v1576811179/71576811153_.pic_hd_lp9y00.jpg"><br>这篇文本中的所有ID都能抓取到，连 xxx丶xx格式的ID也能抓取所以抓取的面应该是比较广的。</p><h4 id="5-GUI-界面"><a href="#5-GUI-界面" class="headerlink" title="5. GUI 界面"></a>5. GUI 界面</h4><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p>由于是给新手用的，所以打算建立一个GUI互动界面。结果做完了才想起来，新手甚至没有python和GUI的库，所以应该运行不了。。。<br>在pyqt4中进行了UI的绘制，再通过pyqt5 BasicUI.ui -o BasicUI.py 进行转换。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p>UI源文件</p><pre><code class="python">    # -*- coding: utf-8 -*-        # Form implementation generated from reading ui file &#39;liwu.ui&#39;    \#    # Created by: PyQt5 UI code generator 5.7.1    \#    # WARNING! All changes made in this file will be lost!        from PyQt5 import QtCore, QtGui, QtWidgets        class Ui\_MainWindow(object):        def setupUi(self, MainWindow):        MainWindow.setObjectName(&quot;MainWindow&quot;)        MainWindow.resize(800, 600)        self.centralwidget = QtWidgets.QWidget(MainWindow)        self.centralwidget.setObjectName(&quot;centralwidget&quot;)        self.pushButton = QtWidgets.QPushButton(self.centralwidget)        self.pushButton.setGeometry(QtCore.QRect(350, 240, 92, 27))        self.pushButton.setObjectName(&quot;pushButton&quot;)        MainWindow.setCentralWidget(self.centralwidget)        self.menubar = QtWidgets.QMenuBar(MainWindow)        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 25))        self.menubar.setObjectName(&quot;menubar&quot;)        MainWindow.setMenuBar(self.menubar)        self.statusbar = QtWidgets.QStatusBar(MainWindow)        self.statusbar.setObjectName(&quot;statusbar&quot;)        MainWindow.setStatusBar(self.statusbar)            self.retranslateUi(MainWindow)        QtCore.QMetaObject.connectSlotsByName(MainWindow)        def retranslateUi(self, MainWindow):        _translate = QtCore.QCoreApplication.translate        MainWindow.setWindowTitle(_translate(&quot;MainWindow&quot;, &quot;MainWindow&quot;))        self.pushButton.setText(_translate(&quot;MainWindow&quot;, &quot;liwu&quot;))</code></pre><p>以及UI的引用文件</p><pre><code class="python">#coding:utf8import reimport osimport codecsimport sysfrom PyQt5.QtWidgets import QMainWindow, QApplication, QFileDialogfrom liwu import *#from pyparsing import unicodefrom numpy import unicode########################################################   Author:     &lt;Your Full Name&gt;#   email:      &lt;Your Email&gt;#   ID:         &lt;Your course ID, e.g. ee364j20&gt;#   Date:       &lt;Start Date&gt;#######################################################class Consumer(QMainWindow, Ui_MainWindow):    def __init__(self, parent=None):        super(Consumer, self).__init__(parent)        self.setupUi(self)        self.pushButton.clicked.connect(self.find_liwu)    def find_liwu(self):        filename = os.listdir(&#39;logfile&#39;)        filepath = []        for element in filename:            if len(element.split(&#39;.txt&#39;)) &gt;= 2:                #print element                filepath.append(element)        feiji = &#39;飞机&#39;        banka = &#39;办卡&#39;        i = 0        bankadic = &#123;&#125;        feijidic = &#123;&#125;        g = 0        num = [0]        patternbanka = str(&#39;感谢 &#39;)+u&#39;[\u4e00-\u9fa5\d\w]+&#39;+str(&#39; 送出的 &#39;)+str(banka)+&#39;[x][\d]+&#39;        patternfeiji = str(&#39;感谢 &#39;) + u&#39;[\u4e00-\u9fa5\d\w]+&#39; + str(&#39; 送出的 &#39;) + str(feiji) + &#39;[x][\d]+&#39;        while i &lt; len(filepath):            path = &#39;logfile/&#39; + filepath[i]            with open(path) as f:                loglines = f.read().splitlines()            j = 0            while j &lt; len(loglines):                line = str(loglines[j])                answer = re.findall(patternbanka,line)                answer1 = re.findall(patternfeiji,line)                #print(answer)                if answer:                #print len(answer)                    g += 1                    #print(answer[0])                    prev = int(num[0])                    patternName = u&#39;(?P&lt;name&gt;[\u4e00-\u9fa5\d\w]+)&#39;+str(&#39; 送出的 &#39;)                    name = re.findall(patternName,answer[0])                    patternNum = str(banka)+&#39;[x](?P&lt;num&gt;[\d]+)&#39;                    num = re.findall(patternNum,answer[0])                    num1 = int(num[0])                    #print name[0], num1, prev                    if name[0] in bankadic.keys():                        if num1 == 1:                            bankadic[name[0]] = bankadic[name[0]] + 1                        elif num1 == 10 and prev != 9:                            bankadic[name[0]] = bankadic[name[0]] + 10                        elif num1 == 66 and prev != 65:                            bankadic[name[0]] = bankadic[name[0]] + 66                        elif num1 == 366 and prev != 365:                            bankadic[name[0]] = bankadic[name[0]] + 366                        elif num1 == 520 and prev != 519:                            bankadic[name[0]] = bankadic[name[0]] + 520                        elif num1 == 1314 and prev != 1313:                            bankadic[name[0]] = bankadic[name[0]] + 1314                        else:                            bankadic[name[0]] = bankadic[name[0]] + 1                    else:                        bankadic[name[0]] = num1                if answer1:                    #print len(answer)                    g += 1                    #print(answer[0])                    prev = int(num[0])                    patternName = u&#39;(?P&lt;name&gt;[\u4e00-\u9fa5\d\w]+)&#39;+str(&#39; 送出的 &#39;)                    name = re.findall(patternName,answer1[0])                    patternNum = str(feiji)+&#39;[x](?P&lt;num&gt;[\d]+)&#39;                    num = re.findall(patternNum,answer1[0])                    num1 = int(num[0])                    #print(name,num)                    #print name[0], num1, prev                    if name[0] in feijidic.keys():                        if num1 == 1:                            feijidic[name[0]] = feijidic[name[0]] + 1                        elif num1 == 10 and prev != 9:                            feijidic[name[0]] = feijidic[name[0]] + 10                        elif num1 == 66 and prev != 65:                            feijidic[name[0]] = feijidic[name[0]] + 66                        elif num1 == 366 and prev != 365:                            feijidic[name[0]] = feijidic[name[0]] + 366                        elif num1 == 520 and prev != 519:                            feijidic[name[0]] = feijidic[name[0]] + 520                        elif num1 == 1314 and prev != 1313:                            feijidic[name[0]] = feijidic[name[0]] + 1314                        else:                            feijidic[name[0]] = feijidic[name[0]] + 1                    else:                        feijidic[name[0]] = num1                j+= 1            i += 1        #print(bankadic.keys()[1], bankadic[bankadic.keys()[1]])        print(feijidic)        f = codecs.open(&#39;liwu.txt&#39;,&#39;w&#39;,&#39;utf-8&#39;)        #print bankadic.keys()[0]        i = 0        while i &lt; (len(bankadic)):            if list(bankadic.keys())[i] in feijidic.keys():                f.write(list(bankadic.keys())[i] + &#39; &#39;+ str(bankadic[list(bankadic.keys())[i]])+str(&#39; 办卡 &#39;)+ str(feijidic[list(bankadic.keys())[i]])+ str(&#39; 飞机&#39;) +&#39;\n&#39;)            else:                f.write(list(bankadic.keys())[i] + &#39; &#39;+ str(bankadic[list(bankadic.keys())[i]])+str(&#39; 办卡&#39;)+  str(&#39; 0  飞机&#39;) +&#39;\n&#39;)            i += 1        i = 0        while i &lt; (len(feijidic)):            if list(feijidic.keys())[i] in bankadic.keys():                f.write(list(feijidic.keys())[i] + &#39; &#39;+ str(bankadic[list(feijidic.keys())[i]])+ str(&#39; 办卡 &#39;)+ str(feijidic[list(feijidic.keys())[i]])+str(&#39; 飞机 &#39;) +&#39;\n&#39;)            else:                f.write(list(feijidic.keys())[i] + &#39; &#39;+ str(&#39; 0 办卡 &#39;)+ str(feijidic[list(feijidic.keys())[i]])+str(&#39; 飞机&#39;)  +&#39;\n&#39;)            i += 1if __name__ == &quot;__main__&quot;:    currentApp = QApplication(sys.argv)    currentForm = Consumer()    currentForm.show()    currentApp.exec_()</code></pre><h3 id="总结与问题"><a href="#总结与问题" class="headerlink" title="总结与问题"></a>总结与问题</h3><p>这个程序大概上能实现功能但是会遇到一下问题。</p><h4 id="1-礼物数量"><a href="#1-礼物数量" class="headerlink" title="1.礼物数量"></a>1.礼物数量</h4><p>如果送了9张办卡后 再送了10张办卡，可能只统计10张。因为程序猜测后面的x10为连击，因为x10前面为x9。这个问题可以用文本读取的方式不能有效解决。</p><p>可能可以用连击的时间来减少误算，但是再连击时间内发生还是无法避免。</p><h4 id="2-送礼者ID"><a href="#2-送礼者ID" class="headerlink" title="2.送礼者ID"></a>2.送礼者ID</h4><p>如果送礼者ID不为汉子英文和数字的话，有大几率会出现遗漏。</p><h4 id="3-程序使用"><a href="#3-程序使用" class="headerlink" title="3.程序使用"></a>3.程序使用</h4><p>该程序还是只能在搭建了环境下才能运行，较为麻烦。</p><h4 id="4-不同版本的python下转码的函数不通用"><a href="#4-不同版本的python下转码的函数不通用" class="headerlink" title="4.不同版本的python下转码的函数不通用"></a>4.不同版本的python下转码的函数不通用</h4><p>在3.7中只能支持str（）进行转码。encode（）好像不支持。</p><h4 id="5-时间"><a href="#5-时间" class="headerlink" title="5.时间"></a>5.时间</h4><p>在处理一个文本花的时间为0.0143s，所以时间应该问题不是很大。</p><h4 id="6-市面上已经有免费的支持API的网站进行查询"><a href="#6-市面上已经有免费的支持API的网站进行查询" class="headerlink" title="6.市面上已经有免费的支持API的网站进行查询"></a>6.市面上已经有免费的支持API的网站进行查询</h4><p>所以本程序在得知这个消息的时候就不怎么打算更新了。</p>]]></content>
      
      
      <categories>
          
          <category> python text </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python - project - text </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux驱动练习</title>
      <link href="/2019/09/06/Linux_driver_practice/"/>
      <url>/2019/09/06/Linux_driver_practice/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>时隔近一个月，准备吧实习的内容在总结一下。这一次上具体的练习的过程。具体准备的是打算写一个简单  的在内核打印hello_world的驱动。</p><span id="more"></span><h1 id="过程介绍"><a href="#过程介绍" class="headerlink" title="过程介绍"></a>过程介绍</h1><ol><li>完成source文件</li><li>完成Makefile</li><li>加载模组，并尝试测试</li></ol><h1 id="source-文件"><a href="#source-文件" class="headerlink" title="source 文件"></a>source 文件</h1><p>以下是练习写的code，按照基本的几个函数构建的驱动模版。在退出这个驱动的时候运行了printk，在内核中打印了出来。代码如</p><pre><code class="c">static int __init hello_init_module(void)&#123;    return misc_register(&amp;hello_miscdevice);&#125;static void __exit hello_cleanup_module(void)&#123;        misc_deregister(&amp;hello_miscdevice);    printk(KERN_ALERT”Hello__world!n”);//在内核中打印function，用printk函数    //return 0;&#125;module_init(hello_init_module);module_exit(hello_cleanup_module);_</code></pre><p> 上述代码表现在在卸载模块的时候，会运行打印函数，最后打印在内核中。具体看下面的完成Makefile<br>在完成了source code以后，需要完成makefile进行编辑，更具需要运行的环境，选择相对应环境的编译工具</p><pre><code class="c">ifneq ($(KERNELRELEASE),)obj-m:=hello_new.oelse#generate the pathCURRENT_PATH:=$(shell pwd)#the absolute pathLINUX_KERNEL_PATH:=/lib/modules/$(shell uname -r)/build#complie objectdefault:    make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules clean:    make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) cleanendif</code></pre><p> 以上的代码是编译内核模块的makefile代码。Linux_Kernel的地址为运行环境的内核头地址。这次编译是在unbuntu文件运行，所以就如上所示。<br>然后需要在终端输入如下指令。</p><pre><code class="c"># include &lt;linux/module.h&gt;# include &lt;linux/types.h&gt; # include &lt;linux/fs.h&gt;# include &lt;linux/version.h&gt;# include &lt;linux/delay.h&gt;# include &lt;linux/crc32.h&gt;# include &lt;linux/interrupt.h&gt;# include &lt;linux/init.h&gt;# include &lt;linux/miscdevice.h&gt;# include &lt;linux/cdev.h&gt; # include &lt;linux/uaccess.h&gt;# define DEV_DRIVER_NAME        &quot;HelloDev&quot;char memory[50]();int hello_open(struct inode * inode, struct file * file)&#123;    return 0;&#125;int hello_close(struct inode * inode, struct file * file)&#123;    return 0;&#125;ssize_t hello_read(struct file *filp, char __user *buff, size_t count, loff_t *pos)&#123;    if (count &gt; strlen(memory))    &#123;        count = strlen(memory);    &#125;  if (count &lt; 0)    &#123;        return -EINVAL;    &#125;    if (copy_to_user(buff,memory,count))&#123;        return EFAULT;    &#125;    return count;&#125;ssize_t hello_write(struct file *filp, const char __user *buff, size_t count,  loff_t *pos)&#123;if (count &gt; strlen(memory))    &#123;        count = strlen(memory);    &#125;  if (count &lt; 0)    &#123;        return -EINVAL;    &#125;    if (copy_from_user(buff,memory,count))&#123;        return EFAULT;    &#125;    return count;&#125;ssize_t hello_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)&#123;    return 0;&#125;ssize_t unlocked_hello_ioctl(struct file *file, unsigned int cmd, unsigned long arg)&#123;    return hello_ioctl(NULL, file, cmd, arg);&#125;static struct file_operations hello_fops = &#123;    .owner            = THIS_MODULE,# if (LINUX_VERSION_CODE &lt; KERNEL_VERSION( 2,6,35 ))   .ioctl     = hello_ioctl,# else   .unlocked_ioctl = unlocked_hello_ioctl,# endif//版本号决定ioct的不同么，但是为什么用编译条件 不直接用if    .open        = hello_open,    .release    = hello_close,    .read       = hello_read,    .write      = hello_write&#125;;static struct miscdevice hello_miscdevice = &#123;    MISC_DYNAMIC_MINOR,//次设备号    DEV_DRIVER_NAME,    &amp;hello_fops,//这个为什么是地址的格式&#125;;//.minor,.name，.fops 可以省略是吗static int __init hello_init_module(void)&#123;    return misc_register(&amp;hello_miscdevice);&#125;static void __exit hello_cleanup_module(void)&#123;        misc_deregister(&amp;hello_miscdevice);    printk(KERN_ALERT”Hello__world!n”);    //return 0;&#125;module_init(hello_init_module);module_exit(hello_cleanup_module);_</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux driver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Driver </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核驱动介绍(2)</title>
      <link href="/2019/08/09/linux-driver2/"/>
      <url>/2019/08/09/linux-driver2/</url>
      
        <content type="html"><![CDATA[<h1 id="详情回顾"><a href="#详情回顾" class="headerlink" title="详情回顾"></a>详情回顾</h1><p>上篇讲述了用动态，静态申请设备号以及注销，今天记录剩下的部分。</p><span id="more"></span><h1 id="创建设备文件"><a href="#创建设备文件" class="headerlink" title="创建设备文件"></a>创建设备文件</h1><ul><li><p>手工创建</p></li><li><p>自动创建</p><h2 id="手工创建"><a href="#手工创建" class="headerlink" title="手工创建"></a>手工创建</h2><p>利用mknod 函数进行手工创建</p><pre><code class="bash">mknod filename type major minor</code></pre></li><li><p>filename  设备文件名字</p></li><li><p>type         设备文件类型</p></li><li><p>major       主设备号</p></li><li><p>minor       次设备号</p></li></ul><p><em>例子</em> mknod s3c241sel c 231 0</p><h1 id="重要的数据结构"><a href="#重要的数据结构" class="headerlink" title="重要的数据结构"></a>重要的数据结构</h1><p>在linux驱动定义里有几个比较重要额度数据结构</p><ul><li>Struct file</li><li>Struct inode</li><li>Struct file_operations<h2 id="Struct-file"><a href="#Struct-file" class="headerlink" title="Struct file"></a>Struct file</h2> 这个数据结构代表的是一个打开的文件。系统中每个打开的文件在内核空间都有一个关联的struct file 。它由内核在打开文件时创建，在文件关闭后释放。 <h2 id="Struct-inode"><a href="#Struct-inode" class="headerlink" title="Struct inode"></a>Struct inode</h2>用来记录文件的物理上的信息，例如文件大小，文件归属，文件权限等等。<h2 id="Struct-file-operations"><a href="#Struct-file-operations" class="headerlink" title="Struct file_operations"></a>Struct file_operations</h2>一个函数指针的集合，定义能在设备上进行的操作。结构中的成员指向驱动中的函数，这些函数实现一个特别的操作，对于不支持的操作保留为NULL。 <h3 id="定义如下"><a href="#定义如下" class="headerlink" title="定义如下"></a>定义如下</h3><pre><code class="c">static struct file_operations shumg_fops = &#123;  .owner = THIS_MODULE,  .ioctl  =  shumg_ioctl,//读写外其他操作  .write  =  shumg_write,//写  .read  =  shumg_read,//读  .open  =  shumg_open,//打开  .release =  shumg_release,//关闭&#125;；</code></pre></li></ul><h1 id="各个函数介绍"><a href="#各个函数介绍" class="headerlink" title="各个函数介绍"></a>各个函数介绍</h1><ul><li>open</li><li>release</li><li>read</li><li>write</li><li>ioctl</li></ul><h2 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h2><pre><code class="c"> int (*open) (struct inode *，struct file *)；</code></pre><p>尽管这常常是对设备文件进行的第一个操作， 不要求驱动声明一个对应的方法。 如果这个项是 NULL，设备打开一直成功，但是你的驱动不会得到通知。</p><p>Open的作用通常初始化了设备，并表明次设备号</p><h2 id="release-close函数"><a href="#release-close函数" class="headerlink" title="release/close函数"></a>release/close函数</h2><pre><code class="c">int (*release) (struct inode *， struct file *)；</code></pre><p>尽管这常常是对设备文件进行的第一个操作， 不要求驱动声明一个对应的方法。 如果这个项是 NULL，设备打开一直成功，但是你的驱动不会得到通知。</p><p>Release的作用通常与Open相反。</p><h2 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h2><pre><code class="c">ssize_t write(int fd,  void *buf, size_t count);</code></pre><h3 id="具体作用"><a href="#具体作用" class="headerlink" title="具体作用"></a>具体作用</h3><p>从设备中读取数据。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>ssize_t在位数不同的操作系统下位数没有变化。</p><ul><li>fd：要读取的文件</li><li>buff： 指向数据缓存</li><li>size_t：大小<br>read和write的buff参数是用户空间指针。因此，它不能被内核代码直接引用，理由是:用户空间指针在内核空间时可能根本是无效的—–没有那个地址的映射<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3></li><li> 返回值等于传递给 read 系统调用的count 参数，表明请求的数据传输成功。</li><li>返回值大于 0，但小于传递给read 系统调用的count 参数，表明部分数据传输成功，根据设备的不同，导致这个问题的原因也不同，一般采取再次读取的方法。</li><li>返回值＝0，表示到达文件的末尾。</li><li>返回值为负数，表示出现错误，并且指明是何种错误。</li><li>在阻塞型 io 中，read 调用会出现阻塞。</li></ul><h2 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h2><pre><code class="c">ssize_t write(int fd, const void *buf, size_t count);</code></pre><h3 id="具体作用-1"><a href="#具体作用-1" class="headerlink" title="具体作用"></a>具体作用</h3><p>向设备发送数据。</p><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><ul><li>返回值等于传递给 write 系统调用的count 参数，表明请求的数据传输成功。</li><li>返回值大于 0，但小于传递给write 系统调用的count 参数，表明部分数据传输成功，根据设备的不同，导致这个问题的原因也不同，一般采取再次读取的方法。</li><li>返回值＝0，表示没有写入任何数据。标准库在调用write 时，出现这种情况会重复调用write。</li><li>返回值为负数，表示出现错误，并且指明是何种错误。错误号的定义参见&lt;linux/ errno.h&gt;</li><li>在阻塞型 io 中，write 调用会出现阻塞。<h2 id="ioctl函数"><a href="#ioctl函数" class="headerlink" title="ioctl函数"></a>ioctl函数</h2><pre><code class="c">int(*ioctl) (struct inode *inode,struct file *file,unsigned int cmd,unsigned long arg ) </code></pre></li></ul><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul><li>inode：文件物理信息</li><li>file： 内核中的文件</li><li>cmd：需要执行的命令</li><li>arg：带入的参数<h3 id="具体作用-2"><a href="#具体作用-2" class="headerlink" title="具体作用"></a>具体作用</h3>控制设备。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux driver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Driver </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核驱动介绍(1)</title>
      <link href="/2019/08/09/linux-driver1/"/>
      <url>/2019/08/09/linux-driver1/</url>
      
        <content type="html"><![CDATA[<h1 id="驱动介绍"><a href="#驱动介绍" class="headerlink" title="驱动介绍"></a>驱动介绍</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>个人认为驱动就是在底层对于该设备的一些接口进行自己的定义，然后封装成一个个模块，然后让用户在应用层进行自我调用。以下是比较正统的定义。</p><span id="more"></span><p>驱动程序在 Linux 内核里扮演着特殊的角色。 它们是截然不同的”黑盒子”， 使硬件的特殊的一部分响应定义好的内部编程接口。 它们完全隐藏了设备工作的细节. 用户的活动通过一套标准化的调用来进行， 这些调用与特别的驱动是独立的； 设备驱动的角色就是将这些调用映射到作用于实际硬件的和设备相关的操作上。 这个编程接口是这样， 驱动可以与内核的其他部分分开建立， 并在需要的时候在运行时”插入”。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>Linux下对于外部设备只能通过驱动进行访问，同时对于一些接口的调用有统一的方程可以使用。</li><li>驱动程序运用的地址是内核的地址，而不是虚拟地址。</li><li>驱动程序是直接对设备硬件进行控制操作的。<h2 id="驱动分类"><a href="#驱动分类" class="headerlink" title="驱动分类"></a>驱动分类</h2></li><li>字符设备驱动</li><li>块设备驱动</li><li>网络接口驱动</li></ol><p>字符设备：是一种按字节来访问的设备，字符驱动则负责驱动字符设备，这样的驱动通常实现open、close、read和write系统调用。<br>块设备：在大多数UNIX系统，块设备不能按字节处理数据，只能一次传送一个或多个长度是512字节（或一个更大的2次幂的数）的整块数据。<br>网络接口：任何网络事务都通过一个接口来进行，一个接口通常是一个硬件设备（eth0），但是也可以是一个纯粹的软件设备，如回环接口（lo）。一个网络接口负责发送和接受数据报文。 以上的标示和对应数据会在mac系统上用ifconfig在终端中获取。</p><h1 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h1><h2 id="字符设备组成"><a href="#字符设备组成" class="headerlink" title="字符设备组成"></a>字符设备组成</h2><ul><li>设备号</li><li>创建设备文件</li><li>设备注册</li><li>重要数据结构</li><li>设备操作<h2 id="主次设备号"><a href="#主次设备号" class="headerlink" title="主次设备号"></a>主次设备号</h2>主次设备号组成一个设备的设备号。主在前，次在后。<br>分配住主备号有两种：</li><li>静态申请</li><li>动态申请<h3 id="静态申请"><a href="#静态申请" class="headerlink" title="静态申请"></a>静态申请</h3>一般用 cat /proc/devices 确定一个设备号有没有被使用，然后用register_chrdev_region 函数进行注册设备号。<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4>如果不每次查找是否有该设备，会容易发生设备号冲突，导致驱动程序无法注册。每次查找又很麻烦。<h4 id="具体函数及操作"><a href="#具体函数及操作" class="headerlink" title="具体函数及操作"></a>具体函数及操作</h4><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><pre><code class="c">int register_chrdev_region(dev_t from,unsigned count,const char *name)</code></pre></li></ul><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>from：为主设备号与次设备号的组合<br>count：为要注册的设备号的数量<br>name： 设备名字（具体体现在proc/devices 中显示的名字）</p><h3 id="动态申请"><a href="#动态申请" class="headerlink" title="动态申请"></a>动态申请</h3><p>用alloc_chrdev_region分配设备号，不需要查表。但是设备号得在安装完驱动后才能获取，因为安装前没有分配主设备号。</p><h4 id="具体函数及操作-1"><a href="#具体函数及操作-1" class="headerlink" title="具体函数及操作"></a>具体函数及操作</h4><h5 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h5><pre><code class="c">int alloc_chrdev_region(dev_t *dev,unsigned baseminor,unsigned count,const char *name)</code></pre><h5 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h5><p>dev： 分配到的设备号<br> baseminor： 起始次设备号<br> count： 要注册的设备号个数<br> name： 设备名</p><p>篇幅有限，之后的见下一篇。</p>]]></content>
      
      
      <categories>
          
          <category> Linux driver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Driver </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP &amp; UDP 局域网应用</title>
      <link href="/2019/08/05/TCP&amp;UDP/"/>
      <url>/2019/08/05/TCP&amp;UDP/</url>
      
        <content type="html"><![CDATA[<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>一般而言，路由器的作用是把不同网段的内网外网进行连接，进行传输数据。因为绝大多数内网IP地址很可能是相同的。相对而言，一个IP地址其实是一个设备的一个标识。那如果那么多设备的IP地址一样，那服务器还怎么区分需要输送数据到那台设备呢。所以这时候就需要路由器，给需要访问外网的内网设备一个处理过的IP地址。</p><span id="more"></span><h2 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h2><p>有些朋友可能在家里配置过家里的路由器，一般而言进入路由器地址进行配置的IP是192.168.1.1。所以这些地址确实会是重复的。</p><h1 id="如何实现数据交互"><a href="#如何实现数据交互" class="headerlink" title="如何实现数据交互"></a>如何实现数据交互</h1><p>通过今年暑假的实习，也粗略的了解了一些互联网的知识，然后搭建了一个类似一下的一个局域网网络。<br><img src="https://res.cloudinary.com/djyodckal/image/upload/v1564988402/WechatIMG5_tnqecw.jpg" alt=" WechatIMG5 "><br>由途中可知，在LAN口这端的内网是可以直接连接外网的，可以通过ping测试是否可以从内网连接至外网。<br>而在WAN口这端的外网是无法直接连通内网的，其中有很多种办法。这里我用的是端口映射（TCP&amp;UDP）来实现。</p><h1 id="端口映射理解"><a href="#端口映射理解" class="headerlink" title="端口映射理解"></a>端口映射理解</h1><p>对于本人而言，端口映射表现在外网访问一个可能不唯一的内网地址的时候（因为内网地址可能会有重复，在一个路由器下面可能还有路由器进行分配独立的内网地址，所有当只有一个ip地址的时候，可能未必能定位是哪个（自己理解可能不正确））会在输入内网ip的同时额外补充一个端口号，这个端口号具体体现在锁定那个需要信息交互的IP地址。</p><h2 id="举例1-1"><a href="#举例1-1" class="headerlink" title="举例1"></a>举例1</h2><p>显示为192.168.1.254:4000<br>^                     ^<br>   IP 地址.           端口号</p><h1 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h1><h2 id="1-访问路由器地址进行路由器配置"><a href="#1-访问路由器地址进行路由器配置" class="headerlink" title="1. 访问路由器地址进行路由器配置"></a>1. 访问路由器地址进行路由器配置</h2><h3 id="a）登陆路由器地址"><a href="#a）登陆路由器地址" class="headerlink" title="a）登陆路由器地址"></a>a）登陆路由器地址</h3><p>一般而言，内网只有一个路由器的话，路由器IP地址一般为192.168.1.1<br><img src="https://res.cloudinary.com/djyodckal/image/upload/v1564988405/WechatIMG7_njq2st.jpg"><br>在任意网页输入路由器IP地址进入配置路由器界面，首次访问可能需要输入路由器账号密码，默认为账号：admin，密码：admin。</p><h3 id="b）配置允许访问该路由器的设备"><a href="#b）配置允许访问该路由器的设备" class="headerlink" title="b）配置允许访问该路由器的设备"></a>b）配置允许访问该路由器的设备</h3><p>具体通过访问路由器设备的IP地址和MAC地址。（网络地址：访问网络的标签和物理地址：设备独有的标签）如下图所示，从上至下为mac的IP地址和Mac地址，在Mac上搭载的虚拟机的IP地址和Mac地址和在外网的Windows端的IP地址和Mac地址。如上所示，因为要建立路由而不是交换机，WAN口和LAN口的网段并不一样。192.168.1.x和192.168.232.x，其中232也是随机设的值。具体为外网访问静态路由器IP是输入的端口号将对于这里输入的内网IP。<br><img src="https://res.cloudinary.com/djyodckal/image/upload/v1564988407/WechatIMG10_xb7gcf.jpg"></p><h3 id="c）设置外网WAN口网络设置"><a href="#c）设置外网WAN口网络设置" class="headerlink" title="c）设置外网WAN口网络设置"></a>c）设置外网WAN口网络设置</h3><p>因为本人设置的是外网的静态IP所以需要额外设置，因为外网网段为192.168.232.x所以只需设置一个与外网设备不同但同网段的IP，如192.168.232.3而不是Windows段的192.168.232.2。当时本人设成同一个IP，然后在端口映射测试上花费了颇多时间。<br><img src="https://res.cloudinary.com/djyodckal/image/upload/v1564988406/WechatIMG9_ispyvc.jpg"></p><h3 id="d）设置端口转发"><a href="#d）设置端口转发" class="headerlink" title="d）设置端口转发"></a>d）设置端口转发</h3><p>然后开始配置端口转发的功能，给出外网访问路由器的WAN口外网静态IP地址后输入相对应端口后跳转到内网哪个IP地址，然后同意TCP和UDP协议就OK了。<br><img src="https://res.cloudinary.com/djyodckal/image/upload/v1564988413/WechatIMG11_ct8jbn.jpg"></p><p>至此，路由器上的端口转发设置就全部完成了！</p><h2 id="2-配置进行tcp数据传输"><a href="#2-配置进行tcp数据传输" class="headerlink" title="2. 配置进行tcp数据传输"></a>2. 配置进行tcp数据传输</h2><h3 id="a）选择工具"><a href="#a）选择工具" class="headerlink" title="a）选择工具"></a>a）选择工具</h3><ol><li>Windows我选择的是TCP&amp;UDP测试工具 1.02版本）使用iperf 2.0 java版测试带宽</li><li>Mac我选择是app store的异米网络工具</li><li>linux我选择是iperf3（最后又借助telnet测试是否联通）<h3 id="b-1）进行-1-gt-2-互联"><a href="#b-1）进行-1-gt-2-互联" class="headerlink" title="b.1）进行 1 -&gt; 2 互联"></a>b.1）进行 1 -&gt; 2 互联</h3>Mac端异米网络工具<br><img src="https://res.cloudinary.com/djyodckal/image/upload/v1564988408/WechatIMG12_zcetsn.jpg"><br>Windows段TCP&amp;UDP测试工具<br><img src="https://res.cloudinary.com/djyodckal/image/upload/v1564988410/WechatIMG13_kg4ia3.jpg"><br>配置如上图所示<br>位于内网的mac端访问外网Windows端之间输入目标IP就可直接访问，（端口不一样好像也能访问，但是可能是只有两台设备的原因）而位于外网的设备访问内网就得输入路由器WAN口的IP地址也就是之前关于网络静态的设置IP再加上防火墙上设置的端口转移的端口号。然后在两端都有接收到信息。<h3 id="b-2）进行1-gt-3互联"><a href="#b-2）进行1-gt-3互联" class="headerlink" title="b.2）进行1-&gt; 3互联"></a>b.2）进行1-&gt; 3互联</h3>这次用了iperf 2.0 java版本进行互联<br><img src="https://res.cloudinary.com/djyodckal/image/upload/v1564988412/WechatIMG16_msnbpa.jpg"><br>这次用了iperf3 ubuntu命令行<br><code>iperf3 -c 192.169.232.2 -f -k</code><br>上两图图是以windows外网作为服务端，所建立的连接</li></ol><p> <em>这里用iperf2和iperf3互联一定要打开jperf2中“Enable Compatibility Mode”，因为两个版本不同。</em><br><img src="https://res.cloudinary.com/djyodckal/image/upload/v1564988412/WechatIMG17_cyaqh3.jpg"><br>最后附上一张测试带宽的图，配上输出的文本，用python算出了最大带宽。<br><img src="https://res.cloudinary.com/djyodckal/image/upload/v1564988414/WechatIMG20_g6a2ov.jpg"><br>实现代码如下：</p><pre><code class="python">import os      # List of  module  import  statementsimport reDataPath = os.path.expanduser(&#39;/Volumes/CENA_X64FRE&#39;)def findMaxBandwidth(name):filename1 = DataPath + namewith open(filename1) as f:lines1 = f.read().splitlines()patternIP = &quot;[0-9]()&#123;1,3&#125;[.]()[0-9]()&#123;1,3&#125;[.]()[0-9]()&#123;1,3&#125;[.]()[0-9]()&#123;1,3&#125;&quot;IPs = re.findall(patternIP,lines1[5]()+lines1[6]())patternBandWidth = &quot;[0-9]()+[ \t]()Kbits/sec&quot;i = 0bandwidthList =[]()while i \&lt; len(lines1):bandwidth = re.findall(patternBandWidth,lines1[i]())if bandwidth != []():bandwidthList.append(int(bandwidth[0]().split(&#39; &#39;)[0]()))i += 1MaxBandwidth = max(bandwidthList)return (IPs,MaxBandwidth)if __name__  == &quot;__main__&quot;:answer = findMaxBandwidth(&quot;/TCP_WANtoLAN&quot;)IPs = answer[0]()MaxBandwidth = answer[1]()print(&quot;TCP: &quot;)print(&quot;Local IP: &quot; + IPs[0]() + &quot; destinated IP: &quot; + IPs[1]())print(&quot;bandwidth: &quot; + str(round(int(MaxBandwidth)/1024.0,2))+ &#39;M/s&#39;)answer2 = findMaxBandwidth(&quot;/UDP_WANtoLAN&quot;)IPs2 = answer2[0]()MaxBandwidth2 = answer2[1]()print(&quot;UDP: &quot;)print(&quot;Local IP: &quot; + IPs2[0]() + &quot; destinated IP: &quot; + IPs2[1]())print(&quot;bandwidth: &quot; + str(round(int(MaxBandwidth2)/1024.0,2))+&#39;M/s&#39;)</code></pre><p>至此网络协议相关就结束了</p>]]></content>
      
      
      <categories>
          
          <category> TCP &amp; UDP 介绍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP &amp; UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python正则表达式两者取一的表达</title>
      <link href="/2019/08/02/python%20(regex_either%20_expression)/"/>
      <url>/2019/08/02/python%20(regex_either%20_expression)/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>曾经要用正则表达式从.txt或者.dat文本中寻找mac的地址的办法<br>目标数据 2a:3v:5g:3k:3d:6h或者2a-3v-5g-3k-3d-6h<br>可能是由于是16进制，字母不允许大于f。英文字符无视大小写。</p><span id="more"></span><h4 id="一开始的错误代码"><a href="#一开始的错误代码" class="headerlink" title="一开始的错误代码"></a>一开始的错误代码</h4><pre><code class="python">&quot;[a-fA-F0-9](#)2[:-](#)[a-fA-F0-9](#)2[:-](#)[a-fA-F0-9](#)2[:-](#)[a-fA-F0-9](#)2[:-](#)[a-fA-F0-9](#)2[:-](#)[a-fA-F0-9](#)2&quot;</code></pre><p>由于这个正则表达式能抓取一些错误的例子。</p><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><p> <strong>输入</strong>: 2a-3v:5g-3k:3d:6h<br><strong>输出</strong>: 2a-3v:5g-3k:3d:6h<br>会出现”:”与”-“混用的例子，这些是错误的例子。由于输出的顺序必须和文本出现的顺序一致，所以不能分开来查找，于是就做了如下的修改。</p><pre><code class="python">&quot;(?:[a-fA-F0-9](#)2[:](#)[a-fA-F0-9](#)[:](#)[a-fA-F0-9](#)2[:](#)[a-fA-F0-9](#)2[:](#)[a-fA-F0-9](#)2[:](#)[a-fA-F0-9](#)2|[a-fA-F0-9](#)2[-](#)[a-fA-F0-9](#)[-](#)[a-fA-F0-9](#)2[-](#)[a-fA-F0-9](#)2[-](#)[a-fA-F0-9](#)2[-](#)[a-fA-F0-9](#)2)&quot;</code></pre><p>其中(? |-)表示的是两种只能有一种。要不就是全部：衔接的，要不就是全部-衔接的mac地址表达式。</p>]]></content>
      
      
      <categories>
          
          <category> Python Regex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python读取文件去掉空格读取数据方法</title>
      <link href="/2019/08/02/python(delete_space)/"/>
      <url>/2019/08/02/python(delete_space)/</url>
      
        <content type="html"><![CDATA[<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>读取.txt或者.dat文件然后转成list类型，方便读取数据。</p><span id="more"></span><p><img src="https://img-blog.csdnimg.cn/20190406110524542.png"></p><pre><code class="python">list(filter(None,lines[i].split(&#39; &#39;)))[x]`</code></pre><p>通过把空格替换成None来消除空格，x为数据的列数。</p>]]></content>
      
      
      <categories>
          
          <category> Python text </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 文档 </tag>
            
            <tag> 去空格 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32 C编程入门记录 Timers(下)</title>
      <link href="/2019/08/02/STM32(2)/"/>
      <url>/2019/08/02/STM32(2)/</url>
      
        <content type="html"><![CDATA[<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>在上篇文章中讲述了如何把GPIO的端口绑定到TIM上，接下来讲一下如何设置TIM的配置。</p><span id="more"></span><h2 id="过程总览"><a href="#过程总览" class="headerlink" title="过程总览"></a>过程总览</h2><p>– 设置prescaler（预分频器）<br>– 设置the auto-reload（自动重制）<br>– 设置direction/mode of the counter（计数的方向）<br>– 设置output compare mode（输出选择比较方式）<br>– 打开频道连接到端口<br>– 打开 timer的计数器</p><h3 id="1-预分频器"><a href="#1-预分频器" class="headerlink" title="1.预分频器"></a>1.预分频器</h3><p>预分频器就是重复一个计数轮回的次数。代码表述如下：<br>    TIM3-&gt;PSC = 12000 – 1;//重复轮回的次数为12000，因为是从0 开始的所以0-11999为12000.<br>由于TIM的最大频率是48Mhz，所以要得到想要的频率，就要通过运算得知预分频器和计数的值。<br>下面是公式<br>想要的频率 = 48 000 000 / （（TIM3-&gt;PSC + 1 ）*（TIM3-&gt;ARR + 1 ）</p><p>TIM3-&gt;ARR这个会在接下来进行介绍。</p><h3 id="2-自动重制"><a href="#2-自动重制" class="headerlink" title="2.自动重制"></a>2.自动重制</h3><p>自动重制的值为一个计数器从0数到的值。代表计数器达到这个值以后下一位就会清零。<br><code>TIM3-&gt;ARR = 4000 – 1;</code><br>和上面的代码结合起来就可以了解到，这两个值和想到得到的TIM频率的乘积就是TIM的最大乘积48Mhz。</p><h3 id="3-计数器初始值"><a href="#3-计数器初始值" class="headerlink" title="3.计数器初始值"></a>3.计数器初始值</h3><p>这个值决定了计数器的开始值，通过改变不同频道的初始值可以让相同事件以不同的时间但是相同的频率运行。<br>    TIM3-&gt;CCR3 = 3456;<br>当一个完整的频率完成的时候，将会输出一个CK_CNT给输出</p><h3 id="4-输出的模式"><a href="#4-输出的模式" class="headerlink" title="4.输出的模式"></a>4.输出的模式</h3><p>stm32TIM输出的模式大概主要的有8种：通过不同的凡是输出的信号也会有不同。<br>0000: 输出冻结，没有任何事发生。<br>0001: 当CNT（计数比较值）的值等于计数的值，输出将变成高平电压。<br>0010: 当CNT的值（计数比较值）的值等于计数的值，输出将变成低平电压。<br>0011: 当CNT的值（计数比较值）的值等于计数的值，输出将与当前相反。<br>0100: 强制低平电压，且永远不会发生改变。<br>0101: 强制高平电压，且永远不会发生改变。<br>0110: PWM输出模式1，如果计数是往上数的，如果自己当得到的频率的值小于计数的值，高平电压。其他的低平电压。<br>如果计数是往下数的，如果自己当得到的频率的值大于计数的值，高平电压。其他的低平电压<br>0111: PWM输出模式2，如果计数是往上数的，如果自己当得到的频率的值大于等于计数的值，高平电压。其他的低平电压。<br>如果计数是往下数的，如果自己当得到的频率的值大于计数的值，高平电压。其他的低平电压。</p><p>然后模式的选择在输出比较模式的寄存器。<br>代码如下:</p><h5 id="举例：选择0011"><a href="#举例：选择0011" class="headerlink" title="举例：选择0011"></a>举例：选择0011</h5><pre><code>TIM3-&gt;CCMR2 &amp;= TIMCCMR2_OC3M2; //把位数2的值清零，因为有可能先前赋的值没有清零。TIM3-&gt;CCMR2 |= TIM_CCMR2_OC3M_1 | TIM_CCMR2_OC3M_0;//给位数1，0的值清零，因为有可能先前赋的值没有清零。</code></pre><h3 id="5-启动"><a href="#5-启动" class="headerlink" title="5. 启动"></a>5. 启动</h3><p>当上面的配置设置好了以后，就可以启动计数器了，让TIM生效。</p><p>以上就是stm32 TIM功能的介绍及实现。</p>]]></content>
      
      
      <categories>
          
          <category> STM32 TIMER </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> TIMER </tag>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyqt5 textbox中识别整数与小数无报错办法</title>
      <link href="/2019/08/02/Pyqt5_whaterever_datatype/"/>
      <url>/2019/08/02/Pyqt5_whaterever_datatype/</url>
      
        <content type="html"><![CDATA[<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>要求对如下计算机进行编程。可以是任何输入，但只有整数或者小数，结果才有值。</p><span id="more"></span><p><img src="https://img-blog.csdnimg.cn/20190406100216180.png"><br>要求无论什么输入都不允许有报错。<br>所以我就用了正则表达式来做。</p><p>在查看了calculator.io 转换而来的.py文件的时候</p><pre><code class="python">self.edtNumber1 = QtWidgets.QLineEdit(self.centralwidget)self.edtNumber1.setGeometry(QtCore.QRect(70, 50, 146, 27))self.edtNumber1.setObjectName(&quot;edtNumber1&quot;)self.edtNumber2 = QtWidgets.QLineEdit(self.centralwidget)self.edtNumber2.setGeometry(QtCore.QRect(360, 50, 146, 27))self.edtNumber2.setObjectName(&quot;edtNumber2&quot;)self.lblNumber1 = QtWidgets.QLabel(self.centralwidget)self.lblNumber1.setGeometry(QtCore.QRect(110, 30, 71, 17))self.lblNumber1.setObjectName(&quot;lblNumber1&quot;)self.lblNumber2 = QtWidgets.QLabel(self.centralwidget)self.lblNumber2.setGeometry(QtCore.QRect(400, 30, 71, 17))self.lblNumber2.setObjectName(&quot;lblNumber2&quot;)</code></pre><p>得知self.edtNumber1为box1的输入，self.edtNumber2为box2的输入。<br>以下是实现计算器的最终代码</p><pre><code class="python">pattern =&#39;(?P\&lt;number\&gt;[+-] ?[0-9] *[.] [0-9] +)&#39;match=re.search(pattern,self.edtNumber2.text())if match !=None and match[&quot;number&quot;]  == self.edtNumber2.text():number2 = float(match[&quot;number&quot;] )pattern1 =&#39;(?P\&lt;number\&gt;[+-] ?[0-9] +)&#39;match1=re.search(pattern1,self.edtNumber2.text())if match == None and match1 != None and match1[&quot;number&quot;]  == self.edtNumber2.text():number2 = int(match1[&quot;number&quot;] )</code></pre><h2 id="一开始的想法"><a href="#一开始的想法" class="headerlink" title="一开始的想法"></a>一开始的想法</h2><p>因为要判断小数还是整数，所以先判断数据类型。但是因为用正则表达式的话，满足整数的表达式也能在小数中找到。所以要改变查找整数和小数的顺序。</p><h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a><strong>举例</strong>：</h3><p><strong>输入</strong>：12.78</p><pre><code class="python">pattern =&#39;(?P\&lt;number\&gt;[+-] ?[0-9] *[.] [0-9] +)&#39;match=re.search(pattern,self.edtNumber2.text())</code></pre><p>用着整数的正则先查找，匹配如下。<br><strong>输出</strong>：==12==.==78==<br>12, 78<br>显然，这是一个小数而不是整数。<br>所以先判断小数，再根据非小数的结果判断是否有整数。<br>所以就有了原先的判断语句。</p><p><code> if match == None and match1 != None：</code></p><p>来找到不符合小数却符合整数的类型。</p><h2 id="但是出现了另一个问题"><a href="#但是出现了另一个问题" class="headerlink" title="但是出现了另一个问题"></a><strong>但是出现了另一个问题</strong></h2><p>就是该方法无法读取正确大的结果<br>如果输入如下</p><h3 id="举例1："><a href="#举例1：" class="headerlink" title="举例1："></a><strong>举例1</strong>：</h3><p><strong>输入</strong>：12.78De<br><strong>输出</strong>：==12.78==<br>这不是我们想要的结果。<br>于是就做了如下修改。</p><p><code>if match !=None and match[&quot;number&quot;]== self.edtNumber2.text()</code></p><p>除了满足正则表达式的例子外，不应该有其他任何字符。</p><h3 id="举例2："><a href="#举例2：" class="headerlink" title="举例2："></a><strong>举例2</strong>：</h3><p><strong>输入</strong>：12.78De<br>match<a href="#">“number”</a> == 12.78<br>self.edtNumber2.text() == 12.78De<br>(match<a href="#">“number”</a> == self.edtNumber2.text()) == False<br>运用了这个方法后，就不再需要整数与小数先后的办法了。因为不是正确的数据类型的话，在第二个if条件就会出错。<br>最后下面是完整代码</p><pre><code class="python">import re  import sys  from PyQt5 import QtCore, QtGui  from PyQt5.QtWidgets import QMainWindow, QApplication,QFileDialogfrom calculator import * class MathConsumer(QMainWindow, Ui_MainWindow):def __init__(self, parent=None): super(MathConsumer, self).__init__(parent) self.setupUi(self) self.btnCalculate.clicked.connect(self.calculate)# self.btnCalculate.clicked.connect(performOperation())# self.lblNumber1 =def calculate(self):number1 = &#39;E&#39;number2 = &#39;E&#39;# print(float(self.edtNumber1.text()))self.edtNumber1.text()pattern =&#39;(?P\&lt;number\&gt;[+-]() ?[0-9]() *[.]() [0-9]() +)&#39;match=re.search(pattern,self.edtNumber1.text())if match !=None and match[&quot;number&quot;]()  == self.edtNumber1.text():number1 = float(match[&quot;number&quot;]() )pattern1 =&#39;(?P\&lt;number\&gt;[+-]() ?[0-9]() +)&#39;match1=re.search(pattern1,self.edtNumber1.text())if match == None and match1 != None and match1[&quot;number&quot;]()  == self.edtNumber1.text():number1 = int(match1[&quot;number&quot;]() )pattern =&#39;(?P\&lt;number\&gt;[+-]()?[0-9]() *[.]() [0-9]() +)&#39;match=re.search(pattern,self.edtNumber2.text())if match !=None and match[&quot;number&quot;]()  == self.edtNumber2.text():number2 = float(match[&quot;number&quot;]() )pattern1 =&#39;(?P\&lt;number\&gt;[+-]() ?[0-9]() +)&#39;match1=re.search(pattern1,self.edtNumber2.text())if match == None and match1 != None and match1[&quot;number&quot;]()  == self.edtNumber2.text():number2 = int(match1[&quot;number&quot;]() )if number1 == &#39;E&#39; or number2 == &#39;E&#39;:self.edtResult.setText(&quot;E&quot;)else:if self.cboOperation.currentText() == &quot;+&quot;:self.edtResult.setText(str(number1 + number2))elif self.cboOperation.currentText() == &quot;*&quot;:self.edtResult.setText(str(number1 * number2))elif self.cboOperation.currentText() == &quot;-&quot;:self.edtResult.setText(str(number1 - number2))elif self.cboOperation.currentText() == &quot;/&quot;:if number2 != 0 or number2 != 0.0:self.edtResult.setText(str(number1 / number2))else:self.edtResult.setText(&quot;E&quot;)if __name__ == &quot;__main__&quot;:currentApp = QApplication(sys.argv)currentForm = MathConsumer()currentForm.show()currentApp.exec_()</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python Regex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 正则表达式 </tag>
            
            <tag> Pyqt5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32 C编程入门记录 Timers(上)</title>
      <link href="/2019/08/02/STM32(1)/"/>
      <url>/2019/08/02/STM32(1)/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍Tim的用途："><a href="#介绍Tim的用途：" class="headerlink" title="介绍Tim的用途："></a>介绍Tim的用途：</h2><p>在stm32里常常需要用Timer来决定一件事项的频率。最简单的例子，如果想让一个LED灯已一个频率闪烁，就要用Tim来确认频率。那接下来就要介绍一下如何建立一个Tim的计时器。</p><span id="more"></span><h2 id="过程介绍"><a href="#过程介绍" class="headerlink" title="过程介绍"></a>过程介绍</h2><h3 id="1-选择计时器"><a href="#1-选择计时器" class="headerlink" title="1.选择计时器"></a>1.选择计时器</h3><p>首先在I/Opin中，我们暂时只能设置输入与输出。alternative和analog mode还没有涉及，参照下图。<br><img src="https://img-blog.csdnimg.cn/20190407085943770.jpg" alt="这是stm32 reference book上的内容"><br>首先我们要用一个general-purpose的pin连接到Tim，所以这里就不再是输入与输出的结果，而是alternate function mode。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>首先打开 I/O port C clock才能给PC中的pin赋值。<br>假设我们要设置PC8为Tim3的启动pin</p><p>RCC-&gt;AHBENR |= RCC_AHBENR_GPIOCEN;//1<br>GPIOC-&gt;MODER &amp;= (3 &lt;&lt;(2  8));//2<br>GPIOC-&gt;MODER |= 2 &lt;&lt;(2 * 8);//3<br>GPIOC-&gt;AFR[1] &amp;= (15&lt;&lt;(48));//4</p><p>1.打开所有GPIOC的pin.<br>2.因为下面要给PC8赋值，所以要先清空原来的数值，否则原来数字或等于10结果可能不为10.ex.10|11=11～=10.<br>3.在上图表格中在moder中一个pin占据两位，moder8在第16位，所以向右移8*2位并赋予二进制10也就是2<br>因为不能改变其他位数上的值所以用“|=”“或”来赋值<br>4.这一步要给把pc8绑定到tim3.<br>需要查datasheet。<br><img src="https://img-blog.csdnimg.cn/20190407091823489.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA4MDIxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因为pc8对应的alternate function 只有一个就不需要再次查表来，再查reference book 中AFR的部分。<br><img src="https://img-blog.csdnimg.cn/20190407092049235.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA4MDIxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因为PC8中的8大于7，所以它属于AFRH组。又因为PC8只有一个alternate function。<br>所以只有赋予0000就行，也就是～（1111）就行了。<br>至此就把PC8和Tim3channel3关联了。<br>接下来就是如何选择Tim3的一些事项，下篇再讲。</p>]]></content>
      
      
      <categories>
          
          <category> STM32 TIMER </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> TIMER </tag>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>介绍</title>
      <link href="/2019/08/02/introduction/"/>
      <url>/2019/08/02/introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="Welcome-to-Rick-Zhang’s-blog"><a href="#Welcome-to-Rick-Zhang’s-blog" class="headerlink" title="Welcome to Rick_Zhang’s blog"></a>Welcome to Rick_Zhang’s blog</h2><p>在下在试了很多次后终于创建了属于自己的博客，实属不易，所以第一稿就先中文写了。</p><span id="more"></span><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>建立属于自己的博客原因有很多，会在下面慢慢论述。其中最主要的原因就是想记录一些自己在学习编程途中的一些想法。然后能加深自己的印象，以便在遇到相似问题的时候能提高效率。<br>第二就是能把自己的一些代码写出来，希望大神能给一些修改的建议，有一个实力的提升。<br>第三就是顺便找实习或工作的时候，能体现自己的所思所想，让别人能更好的了解自己的实力与不足。（毕竟自己实力还很弱，哈哈哈！）</p><h1 id="本博客中的主要内容"><a href="#本博客中的主要内容" class="headerlink" title="本博客中的主要内容"></a>本博客中的主要内容</h1><p>本人是个习惯用python的硬件工程师。处理数据的时候倾向于用python。学硬件的原因也很简单，就是希望能掌握一点东西，然后可以自己动手做一些有趣实用的项目。</p>]]></content>
      
      
      <categories>
          
          <category> 介绍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 介绍 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
